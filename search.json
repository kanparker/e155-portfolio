[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Resources",
    "section": "",
    "text": "Link to E155 Resources"
  },
  {
    "objectID": "project_midpoint/project_midpoint.html",
    "href": "project_midpoint/project_midpoint.html",
    "title": "E155 Final Project: Midpoint Check-In",
    "section": "",
    "text": "Our project is slightly behind where we intended to be by this point. I believe that we misidentified what the midpoint would be for our project, as our two riskiest components sat before our midpoint check-in. We did complete these two major components (FPGA architecture and RX chain), which is a major load off of our project, and we are feeling confident in completion.\n\n\n\nBelow is the electrical schematic for our RX chain. This schematic is a filtering and conditioning circuit for the Analog to Digital Converter. The butterworth filter takes in the analog signal from the audio jack and removes any aliasing. The first opamp is a unity gain amplifier. The second opamp is a summing amplifier that raises the signal from centered around 0V to centered around 2.5V, it is adjusted by varying the 100K potentiometers. Then there is another unity gain amplifier into a non inverting amplifier. The non-inverting amplifier amplifies the signal to fit the ADC input range of 0V to 5V.\nCurrently the summing amplifier and the noninverting amplifier are connected and working. To still be built is the butterworth filter and the ADC is still to be connected."
  },
  {
    "objectID": "project_midpoint/project_midpoint.html#overview",
    "href": "project_midpoint/project_midpoint.html#overview",
    "title": "E155 Final Project: Midpoint Check-In",
    "section": "",
    "text": "Our project is slightly behind where we intended to be by this point. I believe that we misidentified what the midpoint would be for our project, as our two riskiest components sat before our midpoint check-in. We did complete these two major components (FPGA architecture and RX chain), which is a major load off of our project, and we are feeling confident in completion."
  },
  {
    "objectID": "project_midpoint/project_midpoint.html#electrical-schematic",
    "href": "project_midpoint/project_midpoint.html#electrical-schematic",
    "title": "E155 Final Project: Midpoint Check-In",
    "section": "",
    "text": "Below is the electrical schematic for our RX chain. This schematic is a filtering and conditioning circuit for the Analog to Digital Converter. The butterworth filter takes in the analog signal from the audio jack and removes any aliasing. The first opamp is a unity gain amplifier. The second opamp is a summing amplifier that raises the signal from centered around 0V to centered around 2.5V, it is adjusted by varying the 100K potentiometers. Then there is another unity gain amplifier into a non inverting amplifier. The non-inverting amplifier amplifies the signal to fit the ADC input range of 0V to 5V.\nCurrently the summing amplifier and the noninverting amplifier are connected and working. To still be built is the butterworth filter and the ADC is still to be connected."
  },
  {
    "objectID": "project/project_overview/project_overview.html",
    "href": "project/project_overview/project_overview.html",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "Our final project will be to design and build a digital guitar amplifier capable of producing 4 audio effects: distortion, reverb, vibrato, and chorus. Using an iCE 40UP5K FPGA and an ADC, we will sample our guitar output and perform all effects related to time-delay. An STM32L432KC microcontroller will perform all modifications that change the amplitude of our signal in a non-linear way as well as converting our digital signal back to an analog one before recentering and playing our signal.\n\n\n\nOur system will meet the following specifications upon completion:\n\nPlay the processed audio output from a guitar on a speaker.\nImplement real-time digital effects processing on an STM32L432KC microcontroller.\nInterface a UPduino FPGA for control logic and foot pedal input handling.\nPass a clear audio sample through the FPGA memory architecture.\nDesign and integrate an audio amplifier output stage capable of directly driving a small guitar speaker or external cabinet.\nDevelop a low-noise analog front-end for clean audio acquisition and output.\nCreate a user-friendly interface using foot pedals for live control and effect toggling.\n\n\n\n\nThe system consists of the following components:\nThe amplifier system consists of the following main components:\n\nSTM32L432KC MCU:\n\nTakes sampled input data from the FPGA and applies some audio distortion effects. Drives the speaker through an audio amplifier by outputting a wave signal through a DAC channel\n\nUPduino (Lattice iCE40 FPGA):\n\nTakes input from ADC, samples the input frequency and subsequently does some of the delay based audio effects. Outputs the sampled signal or the modified signal to the MCU through SPI communication. Handles the input controls from some of the toggle switches.\n\nAnalog Front-End:\n\nIncludes preamplification, signal conditioning, and level shifting circuits to ensure proper ADC input voltage levels and low-noise operation. The output stage reconditions the signal for amplifier or headphone output.\n\nFoot Pedal Controls:\n\nUp to four pedals are used to toggle each effect (reverb, delay, chorus, distortion) on or off, as well as adjust intensity parameters such as delay time, chorus depth, or reverb level.\n\nAmplifier Output:\n\nPerforms amplification of signal from the MCU which is passed through an audio amplifier chip that drives into a guitar amp.\n\n\n\n\n\nThe FPGA will communicate with an ADC over a serial communication protocol, enabling it to read in 12-bit analog signal. This information will be stored in the FPGA memory before being read out at various times to implement delay based effects in our sound.\n\n\n\nIn this project, the MCU will take data over SPI communications from the FPGA. After this, the MCU will determine whether a distortion and/or vibrato effect should be applied to the signal. It will apply the relevant transformations, and then it will use the onboard DAC to convert back to an analog signal before outputting through the second stage amplifier.\n\n\n\nOur design has two main points that will be high-risk areas for our design: the FPGA design with an unfamiliar component (SRAM) and the analog preamplifier to bring the guitar’s output signal into range for the ADC (0-3.3 V). This design was talked about in class, and we should be able to use the information from lecture to create a preamplifier and appropriately generate our offset. Additionally, when using the SRAM on the FPGA, we should be extra careful to understand the datasheet fully in order to correctly implement the memory-based delay effects.\n\n\n\nTwo major points of our circuit will need to be calculated to find optimal operating conditions; these are the input and output points as well as the internal DSP relevant to making all desired effects.\nOn the analog side, input signal ranges from 0.1 to 1.0 Vpp centered around 0 V, with a frequency between 80 and 5000 Hz. We need to be able to shift the signal and amplify to fit the FPGA input specs of 0 to 3.3 V. this means, for an op-amp:\n\nSlew rate\n\n\\(SR \\geq 2 \\pi f_{max} V_{pk}\\)\n\\(SR \\geq 5 \\frac{V}{\\mu s}\\)\n\nGBW Product\n\nIf max closed loop gain is 10, and we desire a flat response to 100 KHz, choose \\(GBW \\geq 10 * 100 kHz = 1 MHz\\)\n\n\nFor the digital domain, we are mostly worried about the effects of aliasing on our sampled data. Because distortion works by clipping the extreme ranges of our signal, and chorus and reverb work by slightly delaying the phase of our signal before recombining it in some ratio, sampling at a much larger rate than our output frequency (44100 KHz) will enable an appropriately high fidelity output.\n\n\n\nThe following block diagram shows how signals will flow through the system.\n Figure 1: Block diagram of system design\nThe guitar signal will be sent through a pre-processing amplifier that will limit noise as well as increasing the voltage of the guitar’s signal to a readable level. The FPGA will read the signal and convert it to digital, as well as applying the reverb and chorus effects if those pedals are active. The signal is then passed over SPI communication to the MCU, where the distortion and vibrato effects can be applied. Finally, the MCU will use its onboard DAC to convert the signal back to analog, where it will encounter a post-processing amplifier before going into a guitar amplifier.\n\n\n\nThe following GANTT chart shows how work will be broken down over the 5 weeks given for the project.\n Figure 2: GANTT chart showing schedule for project over 5 weeks\n\n\n\nBelow is the bill of materials we have planned for this project:\n Figure 3: BoM for project"
  },
  {
    "objectID": "project/project_overview/project_overview.html#description",
    "href": "project/project_overview/project_overview.html#description",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "Our final project will be to design and build a digital guitar amplifier capable of producing 4 audio effects: distortion, reverb, vibrato, and chorus. Using an iCE 40UP5K FPGA and an ADC, we will sample our guitar output and perform all effects related to time-delay. An STM32L432KC microcontroller will perform all modifications that change the amplitude of our signal in a non-linear way as well as converting our digital signal back to an analog one before recentering and playing our signal."
  },
  {
    "objectID": "project/project_overview/project_overview.html#system-specifications",
    "href": "project/project_overview/project_overview.html#system-specifications",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "Our system will meet the following specifications upon completion:\n\nPlay the processed audio output from a guitar on a speaker.\nImplement real-time digital effects processing on an STM32L432KC microcontroller.\nInterface a UPduino FPGA for control logic and foot pedal input handling.\nPass a clear audio sample through the FPGA memory architecture.\nDesign and integrate an audio amplifier output stage capable of directly driving a small guitar speaker or external cabinet.\nDevelop a low-noise analog front-end for clean audio acquisition and output.\nCreate a user-friendly interface using foot pedals for live control and effect toggling."
  },
  {
    "objectID": "project/project_overview/project_overview.html#system-overview",
    "href": "project/project_overview/project_overview.html#system-overview",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "The system consists of the following components:\nThe amplifier system consists of the following main components:\n\nSTM32L432KC MCU:\n\nTakes sampled input data from the FPGA and applies some audio distortion effects. Drives the speaker through an audio amplifier by outputting a wave signal through a DAC channel\n\nUPduino (Lattice iCE40 FPGA):\n\nTakes input from ADC, samples the input frequency and subsequently does some of the delay based audio effects. Outputs the sampled signal or the modified signal to the MCU through SPI communication. Handles the input controls from some of the toggle switches.\n\nAnalog Front-End:\n\nIncludes preamplification, signal conditioning, and level shifting circuits to ensure proper ADC input voltage levels and low-noise operation. The output stage reconditions the signal for amplifier or headphone output.\n\nFoot Pedal Controls:\n\nUp to four pedals are used to toggle each effect (reverb, delay, chorus, distortion) on or off, as well as adjust intensity parameters such as delay time, chorus depth, or reverb level.\n\nAmplifier Output:\n\nPerforms amplification of signal from the MCU which is passed through an audio amplifier chip that drives into a guitar amp."
  },
  {
    "objectID": "project/project_overview/project_overview.html#fpga-design-details",
    "href": "project/project_overview/project_overview.html#fpga-design-details",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "The FPGA will communicate with an ADC over a serial communication protocol, enabling it to read in 12-bit analog signal. This information will be stored in the FPGA memory before being read out at various times to implement delay based effects in our sound."
  },
  {
    "objectID": "project/project_overview/project_overview.html#mcu-design-details",
    "href": "project/project_overview/project_overview.html#mcu-design-details",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "In this project, the MCU will take data over SPI communications from the FPGA. After this, the MCU will determine whether a distortion and/or vibrato effect should be applied to the signal. It will apply the relevant transformations, and then it will use the onboard DAC to convert back to an analog signal before outputting through the second stage amplifier."
  },
  {
    "objectID": "project/project_overview/project_overview.html#riskiest-elements",
    "href": "project/project_overview/project_overview.html#riskiest-elements",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "Our design has two main points that will be high-risk areas for our design: the FPGA design with an unfamiliar component (SRAM) and the analog preamplifier to bring the guitar’s output signal into range for the ADC (0-3.3 V). This design was talked about in class, and we should be able to use the information from lecture to create a preamplifier and appropriately generate our offset. Additionally, when using the SRAM on the FPGA, we should be extra careful to understand the datasheet fully in order to correctly implement the memory-based delay effects."
  },
  {
    "objectID": "project/project_overview/project_overview.html#calculations",
    "href": "project/project_overview/project_overview.html#calculations",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "Two major points of our circuit will need to be calculated to find optimal operating conditions; these are the input and output points as well as the internal DSP relevant to making all desired effects.\nOn the analog side, input signal ranges from 0.1 to 1.0 Vpp centered around 0 V, with a frequency between 80 and 5000 Hz. We need to be able to shift the signal and amplify to fit the FPGA input specs of 0 to 3.3 V. this means, for an op-amp:\n\nSlew rate\n\n\\(SR \\geq 2 \\pi f_{max} V_{pk}\\)\n\\(SR \\geq 5 \\frac{V}{\\mu s}\\)\n\nGBW Product\n\nIf max closed loop gain is 10, and we desire a flat response to 100 KHz, choose \\(GBW \\geq 10 * 100 kHz = 1 MHz\\)\n\n\nFor the digital domain, we are mostly worried about the effects of aliasing on our sampled data. Because distortion works by clipping the extreme ranges of our signal, and chorus and reverb work by slightly delaying the phase of our signal before recombining it in some ratio, sampling at a much larger rate than our output frequency (44100 KHz) will enable an appropriately high fidelity output."
  },
  {
    "objectID": "project/project_overview/project_overview.html#block-diagram",
    "href": "project/project_overview/project_overview.html#block-diagram",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "The following block diagram shows how signals will flow through the system.\n Figure 1: Block diagram of system design\nThe guitar signal will be sent through a pre-processing amplifier that will limit noise as well as increasing the voltage of the guitar’s signal to a readable level. The FPGA will read the signal and convert it to digital, as well as applying the reverb and chorus effects if those pedals are active. The signal is then passed over SPI communication to the MCU, where the distortion and vibrato effects can be applied. Finally, the MCU will use its onboard DAC to convert the signal back to analog, where it will encounter a post-processing amplifier before going into a guitar amplifier."
  },
  {
    "objectID": "project/project_overview/project_overview.html#schedule-and-work-breakdown",
    "href": "project/project_overview/project_overview.html#schedule-and-work-breakdown",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "The following GANTT chart shows how work will be broken down over the 5 weeks given for the project.\n Figure 2: GANTT chart showing schedule for project over 5 weeks"
  },
  {
    "objectID": "project/project_overview/project_overview.html#bill-of-materialsbudget",
    "href": "project/project_overview/project_overview.html#bill-of-materialsbudget",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "Below is the bill of materials we have planned for this project:\n Figure 3: BoM for project"
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Hello Quarto",
    "section": "",
    "text": "My goals for this semster in micro p’s is to learn as much as I can. I want to get into a good work flow schedule and manage my time well. I think I can achieve this by setting aside specific time to do work and staying focused. We will see"
  },
  {
    "objectID": "labs/lab7/lab7.html",
    "href": "labs/lab7/lab7.html",
    "title": "Lab 7",
    "section": "",
    "text": "Lab 7 tbd"
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5",
    "section": "",
    "text": "Introduction\nSchematic\nFlow Chart\nC Code 4.1 main 4.2 EXTI0_IRQHandler 4.3 EXTI1_IRQHandler 4.4 interupt_setup\nCalculation\nComparison of Manual vs Interupts\nAI Prototype"
  },
  {
    "objectID": "labs/lab5/lab5.html#main",
    "href": "labs/lab5/lab5.html#main",
    "title": "Lab 5",
    "section": "main ",
    "text": "main \nint main(void) {\n    pinMode(PA2,GPIO_OUTPUT);\n    printf(\"Sequence Start\\n\");\n    int volatile n = 0;\n\n    // Set system clock to 80 MHz\n    //configureClock();\n    //configurePLL();\n    //printf(\"Clock Configure\\n\");\n\n    // Enable button as input\n    gpioEnable(GPIO_PORT_A);\n    printf(\"Gpio Enable\\n\");\n    pinMode(PA0, GPIO_INPUT);\n    pinMode(PA1, GPIO_INPUT);\n    pinMode(PA2, GPIO_OUTPUT);\n    printf(\"Pinmode\\n\");\n    GPIOA-&gt;PUPDR |= _VAL2FLD(GPIO_PUPDR_PUPD0, 0b10); // Set PA0 as pull down\n    GPIOA-&gt;PUPDR |= _VAL2FLD(GPIO_PUPDR_PUPD1, 0b10); // Set PA1 as pull down\n    printf(\"Pull Up and Down\\n\");\n\n    // Initialize timer\n    RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;\n    initTIM(DELAY_TIM);\n    printf(\"Timer Initialize\\n\");\n\n    //set up interupts\n    interupt_set();\n    printf(\"Interupt Set\\n\");\n    \n    int volatile leadA;\n    printf(\"Volatile A Set\\n\");\n    int volatile leadB;\n    printf(\"Hit While Loop\\n\");\n    int volatile nn=0;\n    \n    digitalWrite(PA2,PIO_HIGH);\n    while(1){\n        \n\n        //interupt handler\n        EXTI0_IRQHandler();\n        EXTI1_IRQHandler();\n        \n        \n        //calculate speed\n        \n        //write to serial if it has been a second\n        if (write_counter==1000) {\n            speed = (float)(A_count + B_count)/(816.0*2); \n            printf(\"Current Speed is %f REV/s\\n\", speed);\n            write_counter = 0;\n            printf(\"Acount %d Bcount %d \\n\", A_count, B_count);\n            A_count = 0;\n            B_count = 0;\n            printf(\"%d \\n\", nn);\n            nn = nn+1;\n            \n        }\n        \n        //delay and increment counter\n        delay_millis(TIM2,1);\n        write_counter = (write_counter + 1);\n        //printf(\"%d \\n\", write_counter);\n        togglePin(PA2);\n        \n        \n\n    }\n}\nMain Module.\nLink to github with full list of library and header files. Link to Git Hub."
  },
  {
    "objectID": "labs/lab5/lab5.html#exti0_irqhandler",
    "href": "labs/lab5/lab5.html#exti0_irqhandler",
    "title": "Lab 5",
    "section": "EXTI0_IRQHandler ",
    "text": "EXTI0_IRQHandler \nvoid EXTI1_IRQHandler(void) {\n    //read the leads\n    int leadA = digitalRead(PA0);\n    int leadB = digitalRead(PA1);\n    // Check that the button was what triggered our interrupt\n    if (EXTI-&gt;PR1 & (1 &lt;&lt; gpioPinOffset(PA1))){\n        // If so, clear the interrupt (NB: Write 1 to reset.)\n        EXTI-&gt;PR1 |= (1 &lt;&lt; gpioPinOffset(PA1));\n        //Rising Edge\n        if(leadB == 1){\n            //check direction\n            if(leadA ==1){\n                B_count = B_count + 1;\n            }\n            else{\n                B_count = B_count - 1;\n            }\n        }\n        //Falling Edge\n        else{\n            if(leadA ==0){\n                B_count = B_count + 1;\n            }\n            else{\n                B_count = B_count - 1;\n            }\n        }\n    }\n}\nInterupt handler for EXTI0 which is connected to the encoder signal A."
  },
  {
    "objectID": "labs/lab5/lab5.html#exti1_irqhandler",
    "href": "labs/lab5/lab5.html#exti1_irqhandler",
    "title": "Lab 5",
    "section": "EXTI1_IRQHandler ",
    "text": "EXTI1_IRQHandler \nvoid EXTI0_IRQHandler(void) {\n    // Check that the button was what triggered our interrupt\n    int leadA = digitalRead(PA0);\n    int leadB = digitalRead(PA1);\n    if (EXTI-&gt;PR1 & (1 &lt;&lt; gpioPinOffset(PA0))){\n        // If so, clear the interrupt (NB: Write 1 to reset.)\n        EXTI-&gt;PR1 |= (1 &lt;&lt; gpioPinOffset(PA0));\n        //Rising Edge\n        if(leadA == 1){\n            //check direction\n            if(leadB ==0){\n                A_count = A_count + 1;\n            }\n            else{\n                A_count = A_count - 1;\n            }\n        }\n        //Falling Edge\n        else{\n            if(leadB ==0){\n                A_count = A_count - 1;\n            }\n            else{\n                A_count = A_count + 1;\n            }\n        }\n    }\n}\nInterupt handler for EXTI0 which is connected to the encoder signal A."
  },
  {
    "objectID": "labs/lab5/lab5.html#interupt_setup",
    "href": "labs/lab5/lab5.html#interupt_setup",
    "title": "Lab 5",
    "section": "interupt_setup",
    "text": "interupt_setup\nint interupt_set(void) {\n    // 1. Enable SYSCFG clock domain in RCC\n    RCC-&gt;APB2ENR |= RCC_APB2ENR_SYSCFGEN;\n    // 2. Configure EXTICR for the input button interrupt\n    SYSCFG-&gt;EXTICR[1] |= _VAL2FLD(SYSCFG_EXTICR1_EXTI0, 0b000); // Select PA0\n    SYSCFG-&gt;EXTICR[1] |= _VAL2FLD(SYSCFG_EXTICR1_EXTI1, 0b000); // Select PA1\n\n    \n\n    // Configure interrupt for falling and rising edge of GPIO pin for button\n    // 1. Configure mask bit\n    EXTI-&gt;IMR1 |= (1 &lt;&lt; gpioPinOffset(PA0)); // Configure the mask bit\n    EXTI-&gt;IMR1 |= (1 &lt;&lt; gpioPinOffset(PA1)); // Configure the mask bit\n\n    // 2. Enable rising edge trigger\n    EXTI-&gt;RTSR1 |= (1 &lt;&lt; gpioPinOffset(PA0));// Disable rising edge trigger\n    EXTI-&gt;RTSR1 |= (1 &lt;&lt; gpioPinOffset(PA1));// Disable rising edge trigger\n\n    // 3. Enable falling edge trigger\n    EXTI-&gt;FTSR1 |= (1 &lt;&lt; gpioPinOffset(PA0));// Enable falling edge trigger\n    EXTI-&gt;FTSR1 |= (1 &lt;&lt; gpioPinOffset(PA1));// Enable falling edge trigger\n\n    // 4. Turn on EXTI interrupt in NVIC_ISER\n    NVIC-&gt;ISER[0] |= (1 &lt;&lt; EXTI0_IRQn);\n    NVIC-&gt;ISER[0] |= (1 &lt;&lt; EXTI1_IRQn);\n    \n    // Enable interrupts globally\n    __enable_irq();\n    \n}\nInterupt setup and handle."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3",
    "section": "",
    "text": "Lab 3 tbd"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1",
    "section": "",
    "text": "Introduction\nSchematic\nBlock Diagram\nVerilog Code 4.1 top 4.2 seven_segment_display 4.3 three_led\nTest Benches 5.1 testbench 5.2 seven_testbench 5.3 three_testbench\nNotes\nAI Prototype"
  },
  {
    "objectID": "labs/lab1/lab1.html#top",
    "href": "labs/lab1/lab1.html#top",
    "title": "Lab 1",
    "section": "top ",
    "text": "top \nmodule top(\n    input   logic   [3:0]s,\n    output  logic [2:0]led,\n    output logic [6:0]seg\n);\n    //top module for lab1\n    three_led three(s, led);\n    seven_seg_display seven(s,seg);\n    \n    \n\nendmodule\nTop level module."
  },
  {
    "objectID": "labs/lab1/lab1.html#seven_segment_display",
    "href": "labs/lab1/lab1.html#seven_segment_display",
    "title": "Lab 1",
    "section": "seven_segment_display ",
    "text": "seven_segment_display \nmodule seven_seg_display(\n    input   logic   [3:0]s,\n    output  logic [6:0]seg\n);\n    //Seven segment display based on switch inputs, s[3:0] are input switches and seg[6:0] are for each segment of the display\n\n    logic A,B,C,D;\n    \n    assign A = s[3];\n    assign B = s[2];\n    assign C = s[1];\n    assign D = s[0];\n    \n    always_comb\n        case(s[3:0])\n            /// 0\n            4'b0000: seg[6:0] = 7'b0000001;\n            /// 1\n            4'b0001: seg[6:0] = 7'b1001111;\n            /// 2\n            4'b0010: seg[6:0] = 7'b0010010;\n            /// 3\n            4'b0011:seg[6:0] = 7'b0000110;\n            /// 4\n            4'b0100:seg[6:0] = 7'b1001100;\n            /// 5\n            4'b0101:seg[6:0] = 7'b0100100;\n            /// 6\n            4'b0110:seg[6:0] = 7'b0100000;\n            /// 7\n            4'b0111:seg[6:0] = 7'b0001111;\n            /// 8\n            4'b1000:seg[6:0] = 7'b0000000;\n            /// 9\n            4'b1001:seg[6:0] = 7'b0001100;\n            /// A\n            4'b1010:seg[6:0] = 7'b0001000;\n            /// B\n            4'b1011:seg[6:0] = 7'b1100000;\n            /// C\n            4'b1100:seg[6:0] = 7'b0110001;\n            /// D\n            4'b1101:seg[6:0] = 7'b1000010;\n            /// E\n            4'b1110:seg[6:0] = 7'b0110000;\n            /// F\n            4'b1111:seg[6:0] = 7'b0111000;\n        endcase\n            \n    \n\nendmodule\nSeven segment display takes an input of four switches, s[3:0], and ouputs to light up the seven segment display, seg[6:0]"
  },
  {
    "objectID": "labs/lab1/lab1.html#three_led",
    "href": "labs/lab1/lab1.html#three_led",
    "title": "Lab 1",
    "section": "three_led ",
    "text": "three_led \nmodule three_led(\n    input   logic   [3:0]s,\n    output  logic [2:0]led\n);\n    // Three led takes in an input of four switches, s[3:0], and turns on or off leds, led[2:0].\n\n    logic int_osc;\n    logic pulse;\n    logic led_state = 0;\n    logic [31:0] counter = 0;\n    logic [31:0] P;\n    \n    assign P = 32'b00000000000000000000000011010111;\n    \n    // Internal high-speed oscillator\n    HSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(int_osc));\n    \n    // Simple clock divider\n    always_ff @(posedge int_osc)\n        begin\n            counter &lt;= counter + P;\n        end\n    \n    xor x1(led[0],s[1],s[0]);\n    and a1(led[1],s[3],s[2]);\n    \n    assign led[2] = counter[31];\n    \n\nendmodule\nThree led takes in an input of four switches, s[3:0], and turns on or off leds, led[2:0]."
  },
  {
    "objectID": "labs/lab1/lab1.html#test_bench",
    "href": "labs/lab1/lab1.html#test_bench",
    "title": "Lab 1",
    "section": "test_bench ",
    "text": "test_bench \n Link to Test Bench File"
  },
  {
    "objectID": "labs/lab1/lab1.html#seven_testbench",
    "href": "labs/lab1/lab1.html#seven_testbench",
    "title": "Lab 1",
    "section": "seven_testbench ",
    "text": "seven_testbench \n Link to Test Bench File"
  },
  {
    "objectID": "labs/lab1/lab1.html#three_testbench",
    "href": "labs/lab1/lab1.html#three_testbench",
    "title": "Lab 1",
    "section": "three_testbench ",
    "text": "three_testbench \n Link to Test Bench File"
  },
  {
    "objectID": "labs/lab1/lab1.html#reflection",
    "href": "labs/lab1/lab1.html#reflection",
    "title": "Lab 1",
    "section": "Reflection",
    "text": "Reflection\nThe code synthesized well and completed with no errors. The quality overall is pretty decent work however it uses a lot more advance features than what we have covered in class so far. It uses a lot of localparam in unsigned vs just having what I did which was logic and it uses integers vs what I used which was all binary which seems that he LLM made it more readable. Overall it is pretty straight forward just syntaxing is a little unfamilar.\nHow would you rate the quality of the output and why? What SystemVerilog constructs/syntax did the LLM generated that were new to you? Did the LLM-generated code synthesize the first time around? If not, what were the issues? What error or warning messages did Radiant output? What would you do differently the next time you use an LLM in your workflow?"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Hello Quarto\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 29, 205\n\n\nKanoa Parker\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Hi im Kanoa Parker and this is my Portfolio. I’m a senior engineering major at Harvey Mudd College focusing in Electrical Engineering. In my free time I like to listen to music. Here is my LinkedIN\nThis is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2",
    "section": "",
    "text": "Introduction\nSchematic\nBlock Diagram\nVerilog Code 4.1 top 4.2 seven_seg_display 4.3 clock_divider\nTest Benches 5.1 testbench 5.2 seven_testbench\nNotes\n\n7.AI Prototype"
  },
  {
    "objectID": "labs/lab2/lab2.html#top",
    "href": "labs/lab2/lab2.html#top",
    "title": "Lab 2",
    "section": "top ",
    "text": "top \n/*\nTitle: top module for lab 2\nAuthor: Kanoa Parker\nEmail: kanparker@g.hmc.edu\nDate: 9/9/2024\nDescription: Top module for lab 2. Takes in inputs of 2 sets of 4 switches, s1 and s2. Outputs the sum of s1 and s2 as led. Using a time multiplexer the mux choses either to output either s1 or s2 as seg using seven_seg_display module. gate1 and gate1 go to transistor gates which control which set of leds get turned on.\n*/\nmodule top(\n    input logic [3:0]s1,\n    input logic [3:0]s2,\n    output logic [6:0]seg, \n    output logic [4:0]led,\n    output logic gate1, gate2,\n    output logic clk\n);\n    //s1 is inputs of one set of 4 dip swithces\n    //s2 is inputs of other set of 4 dip switches\n    //seg is the output to drive seven segment display\n    // gate1 and gate2 go to base of BJT to control power to seven segment display\n    // clk is output used for testing\n    \n    //sev_seg_in is the input to seven_seg_display module\n    logic [3:0]sev_seg_in;\n    \n    //sev_seg_out is the output of seven_seg_display module\n    logic [6:0]sev_seg_out;\n\n    //instancing seven_seg_display\n    seven_seg_display seven_seg_counter(sev_seg_in,seg);\n    //instancing clock divider\n    clock_divider slow_clock(clk);\n    \n    //muxing between s1 and s2\n    always_comb\n        case(clk)\n            1'b1: begin\n                    sev_seg_in = s1[3:0]; \n                    gate1 = 1'b1;\n                    gate2 =1'b0;\n                end\n            1'b0: begin\n                    sev_seg_in = s2[3:0];\n                    gate1 = 1'b0;\n                    gate2 = 1'b1;\n                end\n        endcase\n    //sum of s1 and s2 to led   \n        assign led = s1 + s2;\n        \nendmodule\nTop module for lab 2. Takes in inputs of 2 sets of 4 switches, s1 and s2. Outputs the sum of s1 and s2 as led. Using a time multiplexer the mux choses either to output either s1 or s2 as seg using seven_seg_display module. gate1 and gate1 go to transistor gates which control which set of leds get turned on."
  },
  {
    "objectID": "labs/lab2/lab2.html#seven_segment_display",
    "href": "labs/lab2/lab2.html#seven_segment_display",
    "title": "Lab 2",
    "section": "seven_segment_display ",
    "text": "seven_segment_display \n/*\nTitle: seven_seg_display\nAuthor: Kanoa Parker\nEmail: kanparker@g.hmc.edu\nDate: 9/9/2024\nDescription: Takes in 4 switch inputs and outputs control signal for a seven segment display\n*/\nmodule seven_seg_display(\n    input   logic   [3:0]s,\n    output  logic [6:0]seg\n);\n    //logic used for old boolean algebra method\n    logic A,B,C,D;\n    \n    assign A = s[3];\n    assign B = s[2];\n    assign C = s[1];\n    assign D = s[0];\n    \n    //old boolean algrebra method\n    /*\n    assign seg[6] = (~A&~C)&(B^D) | A&(~B&C&D | B&~C);\n    assign seg[5] = D&~(A^C) | B&(C&~D | A&~C&~D);\n    assign seg[4] = ~A&~B&C&~D | (A&B)&( ~C&~D | C);\n    assign seg[3] = (~A&D)& ~(B^C) | (A&~B)&(C^D) | B&( ~(A|C|D) | A&C&D);\n    assign seg[2] = (~A&~B&D) | (~A&B&~C) | (~A&B&C&D) | (A&~B&~C&D);\n    assign seg[1] = (~(A|B|C) & D) | (~A&~B&C) | (~A&B&C&D) | (A&B&~C);\n    assign seg[0] = ~(A|B|C|D) | (~A&~B&~C&D) | (~A&B&C&D);\n    */\n    \n    //case statement that map input to output\n    always_comb\n        case(s[3:0])\n            /// 0\n            4'b0000: seg[6:0] = 7'b0000001;\n            /// 1\n            4'b0001: seg[6:0] = 7'b1001111;\n            /// 2\n            4'b0010: seg[6:0] = 7'b0010010;\n            /// 3\n            4'b0011:seg[6:0] = 7'b0000110;\n            /// 4\n            4'b0100:seg[6:0] = 7'b1001100;\n            /// 5\n            4'b0101:seg[6:0] = 7'b0100100;\n            /// 6\n            4'b0110:seg[6:0] = 7'b0100000;\n            /// 7\n            4'b0111:seg[6:0] = 7'b0001111;\n            /// 8\n            4'b1000:seg[6:0] = 7'b0000000;\n            /// 9\n            4'b1001:seg[6:0] = 7'b0001100;\n            /// A\n            4'b1010:seg[6:0] = 7'b0001000;\n            /// B\n            4'b1011:seg[6:0] = 7'b1100000;\n            /// C\n            4'b1100:seg[6:0] = 7'b0110001;\n            /// D\n            4'b1101:seg[6:0] = 7'b1000010;\n            /// E\n            4'b1110:seg[6:0] = 7'b0110000;\n            /// F\n            4'b1111:seg[6:0] = 7'b0111000;\n        endcase\n            \n    //see notes for segment conrispondice to led\n\nendmodule\nSeven segment display takes an input of four switches, s[3:0], and ouputs to light up the seven segment display, seg[6:0]"
  },
  {
    "objectID": "labs/lab2/lab2.html#clock_divider",
    "href": "labs/lab2/lab2.html#clock_divider",
    "title": "Lab 2",
    "section": "clock_divider ",
    "text": "clock_divider \n/*\nTitle: clock_divider\nAuthor: Kanoa Parker\nEmail: kanparker@g.hmc.edu\nDate: 9/9/2024\nDescription: Takes in the standard oscillator adn divides the clock using a counter to produce a clock at desired frequency\n*/\n\nmodule clock_divider(\n    output clk\n);\n    \n    logic int_osc;\n    logic pulse;\n    logic led_state = 0;\n    logic [31:0] counter = 0;\n    logic [31:0] P;\n    \n    assign P = 32'b00000000000000010101111110010000;\n    \n    // Internal high-speed oscillator\n    HSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(int_osc));\n    \n    // Simple clock divider\n    always_ff @(posedge int_osc)\n        begin\n            counter &lt;= counter + P;\n        end\n    assign clk = counter[31];\n        \nendmodule\nTakes in the standard oscillator adn divides the clock using a counter to produce a clock at desired frequency."
  },
  {
    "objectID": "labs/lab2/lab2.html#test_bench",
    "href": "labs/lab2/lab2.html#test_bench",
    "title": "Lab 2",
    "section": "test_bench ",
    "text": "test_bench \n Link to Test Bench File"
  },
  {
    "objectID": "labs/lab2/lab2.html#seven_testbench",
    "href": "labs/lab2/lab2.html#seven_testbench",
    "title": "Lab 2",
    "section": "seven_testbench ",
    "text": "seven_testbench \n Link to Test Bench File"
  },
  {
    "objectID": "labs/lab2/lab2.html#code-ai-provided-first-try",
    "href": "labs/lab2/lab2.html#code-ai-provided-first-try",
    "title": "Lab 2",
    "section": "Code AI Provided first try",
    "text": "Code AI Provided first try\nmodule time_multiplexed_decoder (\n    input logic clk,               // Clock signal\n    input logic rst_n,             // Active-low reset signal\n    input logic [3:0] input_bits_1, // First set of 4-bit input\n    input logic [3:0] input_bits_2, // Second set of 4-bit input\n    output logic [6:0] seg_out_1,   // 7-segment output for the first set\n    output logic [6:0] seg_out_2    // 7-segment output for the second set\n);\n\n    // 7-segment display encoding for common anode (active low segments)\n    // Assuming the 7 segments are ordered as ABCDEF-G\n    logic [6:0] seven_seg_decoder [15:0] = {\n        7'b1111110,  // 0\n        7'b0110000,  // 1\n        7'b1101101,  // 2\n        7'b1111001,  // 3\n        7'b0110011,  // 4\n        7'b1011011,  // 5\n        7'b1011111,  // 6\n        7'b1110000,  // 7\n        7'b1111111,  // 8\n        7'b1111011,  // 9\n        7'b1110111,  // A\n        7'b0011111,  // B\n        7'b1001110,  // C\n        7'b0111101,  // D\n        7'b1001111,  // E\n        7'b1000111   // F\n    };\n\n    // Internal signals for multiplexing control\n    logic mux_ctrl;  // Control signal to alternate between the two sets\n\n    // Time multiplexing logic to alternate between the two sets of inputs\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            mux_ctrl &lt;= 0;  // Reset control signal\n        end else begin\n            mux_ctrl &lt;= ~mux_ctrl;  // Toggle the control signal\n        end\n    end\n\n    // Drive the seven-segment display outputs based on the multiplexed input\n    always_comb begin\n        if (mux_ctrl) begin\n            // Decode the first set of input bits\n            seg_out_1 = seven_seg_decoder[input_bits_1];\n            seg_out_2 = 7'b1111111;  // Turn off second display\n        end else begin\n            // Decode the second set of input bits\n            seg_out_2 = seven_seg_decoder[input_bits_2];\n            seg_out_1 = 7'b1111111;  // Turn off first display\n        end\n    end\n\nendmodule\nThis code was provided without my files. It all compiled and this is the netlist analyzer \n##Code AI provided given my files\n// timescale optional for simulation\n`timescale 1ns/1ps\n\n// Time-multiplex one seven-seg decoder across two inputs to drive two 7-bit busses.\n// Assumes your decoder module is named `seven_seg_display` with ports .s[3:0] and .seg[6:0],\n// and that your clock source is `clock_divider` with port .clk.\nmodule sevenseg_dual_mux #(\n    // If your seven-seg is common-anode (active-low segments), leave ACTIVE_LOW=1.\n    // If it’s common-cathode (active-high segments), set ACTIVE_LOW=0.\n    parameter bit ACTIVE_LOW = 1\n) (\n    input  logic [3:0] s1,        // first 4-bit value\n    input  logic [3:0] s2,        // second 4-bit value\n    output logic [6:0] seg1,      // seven outputs for display 1\n    output logic [6:0] seg2       // seven outputs for display 2\n);\n\n    // -------------------------------------------------------------------------\n    // Clock to flip which input is shown (multiplex rate is set inside clock_divider)\n    // -------------------------------------------------------------------------\n    logic clk_mux;\n    clock_divider u_div (.clk(clk_mux));\n\n    // -------------------------------------------------------------------------\n    // Shared decoder: one instance, two inputs selected by a toggle\n    // -------------------------------------------------------------------------\n    logic        sel;          // which input is currently active\n    logic [3:0]  nibble;       // goes into the shared decoder\n    logic [6:0]  seg_raw;      // comes out of the shared decoder\n\n    // Simple toggle at the divided clock to alternate inputs\n    always_ff @(posedge clk_mux) begin\n        sel &lt;= ~sel;\n    end\n\n    // The single decoder\n    seven_seg_display u_dec (\n        .s   (nibble),\n        .seg (seg_raw)\n    );\n\n    // -------------------------------------------------------------------------\n    // Demultiplex the decoded segments to two 7-bit outputs.\n    // The non-selected display is driven \"blank\" to avoid ghosting.\n    // For active-low segments, \"blank\" = all 1s; for active-high, \"blank\" = all 0s.\n    // -------------------------------------------------------------------------\n    localparam logic [6:0] BLANK = (ACTIVE_LOW) ? 7'b111_1111 : 7'b000_0000;\n\n    always_comb begin\n        // Default blank both\n        seg1  = BLANK;\n        seg2  = BLANK;\n\n        // Select which input feeds the decoder\n        nibble = sel ? s1 : s2;\n\n        // And route the decoder outputs to the selected display\n        if (sel) begin\n            seg1 = seg_raw;\n        end else begin\n            seg2 = seg_raw;\n        end\n    end\n\nendmodule\nCode failed with error “0Runing Export Files failed”"
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4",
    "section": "",
    "text": "Introduction\nSchematic\nMCU Code 4.1 main 4.2 RCC Header 4.3 RCC C File 4.4 TIM 15 and TIM 16 Header 4.5 TIM 15 and TIM 16 C File 4.6 Flash Header 4.7 Flash C File 4.8 GPIO Header 4.9 GPIO C File\nCalculations 5.1 Max Min Delay 5.2 Max Min Frequency 5.2 Error\nNotes\n\n7.AI Prototype"
  },
  {
    "objectID": "labs/lab4/lab4.html#main",
    "href": "labs/lab4/lab4.html#main",
    "title": "Lab 4",
    "section": "main ",
    "text": "main \n/*********************************************************************\n*                    SEGGER Microcontroller GmbH                     *\n*                        The Embedded Experts                        *\n**********************************************************************\n\n-------------------------- END-OF-HEADER -----------------------------\n\nFile    : main.c\nPurpose : Main Header File to Play Song on 8 Ohm speaker\nAuthor: Kanoa Pakrer\nEmail: kanparker@g.hmc.edu\n*/\n\n#include &lt;stdio.h&gt;\n\n/*********************************************************************\n*\n*       main()\n*\n*  Function description\n*   Application entry point.\n*/\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_RCC.h\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_RCC.c\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_TIM_15_16.h\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_TIM_15_16.c\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_GPIO.h\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_GPIO.c\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_FLASH.h\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_FLASH.c\"\n\nconst int notes[][2] = {\n{659,   125},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{494,   125},\n{587,   125},\n{523,   125},\n{440,   250},\n{  0,   125},\n{262,   125},\n{330,   125},\n{440,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{416,   125},\n{494,   125},\n{523,   250},\n{  0,   125},\n{330,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{494,   125},\n{587,   125},\n{523,   125},\n{440,   250},\n{  0,   125},\n{262,   125},\n{330,   125},\n{440,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{523,   125},\n{494,   125},\n{440,   250},\n{  0,   125},\n{494,   125},\n{523,   125},\n{587,   125},\n{659,   375},\n{392,   125},\n{699,   125},\n{659,   125},\n{587,   375},\n{349,   125},\n{659,   125},\n{587,   125},\n{523,   375},\n{330,   125},\n{587,   125},\n{523,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{659,   125},\n{  0,   250},\n{659,   125},\n{1319,  125},\n{  0,   250},\n{623,   125},\n{659,   125},\n{  0,   250},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{494,   125},\n{587,   125},\n{523,   125},\n{440,   250},\n{  0,   125},\n{262,   125},\n{330,   125},\n{440,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{416,   125},\n{494,   125},\n{523,   250},\n{  0,   125},\n{330,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{494,   125},\n{587,   125},\n{523,   125},\n{440,   250},\n{  0,   125},\n{262,   125},\n{330,   125},\n{440,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{523,   125},\n{494,   125},\n{440,   500},\n{  0,   0}};\n\nint main(void) {\n  configureFlash();\n  configureClock();\n  RCC-&gt;AHB2ENR |=(1&lt;&lt;0);\n  RCC-&gt;APB2ENR |= (1 &lt;&lt; 16);\n  RCC-&gt;APB2ENR |= (1 &lt;&lt; 17); // Enable TIM15 and TIM16 clocks\n  RCC-&gt;CFGR &= ~(1 &lt;&lt; 13); // Set APB2 prescaler to /2\n  RCC-&gt;CFGR &= ~(1 &lt;&lt; 7); // Set AHB prescaler to /1\n  pinMode(GPIOA, 0, GPIO_OUTPUT);\n  pinMode(GPIOA, 2, GPIO_OUTPUT);\n  digitalWrite(GPIOA, 0, GPIO_HIGH);\n  //pinMode(GPIOA,1,GPIO_ALT);\n  //pinMode(GPIOA,2,GPIO_ALT);\n  initTIM(TIM15,9);\n  initTIM(TIM16,799);\n  \n  \n    \n  \n  \n\n  \n  int length = sizeof(notes) / sizeof(notes[0]);\n\n  printf(\"%d\\n\", length);  // Prints 5\n  for(int i=0; i&lt;length+1; i++){\n  uint32_t Frequency = notes[i][0];\n  uint32_t delay = notes[i][1];\n  printf(\"Frequency %d Delay %d\\n\", Frequency, delay);\n  \n  if(delay == 0){\n    break;\n  }\n  else{\n    PWM(TIM15,Frequency);\n    delay_millis(TIM16,TIM15,delay,Frequency,GPIOA,0);\n  }\n  }\n  \n  \n  \n  \n\n}\n\n/*************************** End of file ****************************/"
  },
  {
    "objectID": "labs/lab4/lab4.html#rcc-header",
    "href": "labs/lab4/lab4.html#rcc-header",
    "title": "Lab 4",
    "section": "RCC Header ",
    "text": "RCC Header \n// STM32L432KC_RCC.h\n// Header for RCC functions\n\n#ifndef STM32L4_RCC_H\n#define STM32L4_RCC_H\n\n#include &lt;stdint.h&gt;\n\n///////////////////////////////////////////////////////////////////////////////\n// Definitions\n///////////////////////////////////////////////////////////////////////////////\n\n#define __IO volatile\n\n// Base addresses\n#define RCC_BASE (0x40021000UL) // base address of RCC\n\n// PLL\n#define PLLSRC_HSI 0\n#define PLLSRC_HSE 1\n\n// Clock configuration\n#define SW_HSI  0\n#define SW_HSE  1\n#define SW_PLL  2\n\n/**\n  * @brief Reset and Clock Control\n  */\n\ntypedef struct\n{\n  __IO uint32_t CR;          /*!&lt; RCC clock control register,                                              Address offset: 0x00 */\n  __IO uint32_t ICSCR;       /*!&lt; RCC internal clock sources calibration register,                         Address offset: 0x04 */\n  __IO uint32_t CFGR;        /*!&lt; RCC clock configuration register,                                        Address offset: 0x08 */\n  __IO uint32_t PLLCFGR;     /*!&lt; RCC system PLL configuration register,                                   Address offset: 0x0C */\n  __IO uint32_t PLLSAI1CFGR; /*!&lt; RCC PLL SAI1 configuration register,                                     Address offset: 0x10 */\n  uint32_t      RESERVED;    /*!&lt; Reserved,                                                                Address offset: 0x14 */\n  __IO uint32_t CIER;        /*!&lt; RCC clock interrupt enable register,                                     Address offset: 0x18 */\n  __IO uint32_t CIFR;        /*!&lt; RCC clock interrupt flag register,                                       Address offset: 0x1C */\n  __IO uint32_t CICR;        /*!&lt; RCC clock interrupt clear register,                                      Address offset: 0x20 */\n  uint32_t      RESERVED0;   /*!&lt; Reserved,                                                                Address offset: 0x24 */\n  __IO uint32_t AHB1RSTR;    /*!&lt; RCC AHB1 peripheral reset register,                                      Address offset: 0x28 */\n  __IO uint32_t AHB2RSTR;    /*!&lt; RCC AHB2 peripheral reset register,                                      Address offset: 0x2C */\n  __IO uint32_t AHB3RSTR;    /*!&lt; RCC AHB3 peripheral reset register,                                      Address offset: 0x30 */\n  uint32_t      RESERVED1;   /*!&lt; Reserved,                                                                Address offset: 0x34 */\n  __IO uint32_t APB1RSTR1;   /*!&lt; RCC APB1 peripheral reset register 1,                                    Address offset: 0x38 */\n  __IO uint32_t APB1RSTR2;   /*!&lt; RCC APB1 peripheral reset register 2,                                    Address offset: 0x3C */\n  __IO uint32_t APB2RSTR;    /*!&lt; RCC APB2 peripheral reset register,                                      Address offset: 0x40 */\n  uint32_t      RESERVED2;   /*!&lt; Reserved,                                                                Address offset: 0x44 */\n  __IO uint32_t AHB1ENR;     /*!&lt; RCC AHB1 peripheral clocks enable register,                              Address offset: 0x48 */\n  __IO uint32_t AHB2ENR;     /*!&lt; RCC AHB2 peripheral clocks enable register,                              Address offset: 0x4C */\n  __IO uint32_t AHB3ENR;     /*!&lt; RCC AHB3 peripheral clocks enable register,                              Address offset: 0x50 */\n  uint32_t      RESERVED3;   /*!&lt; Reserved,                                                                Address offset: 0x54 */\n  __IO uint32_t APB1ENR1;    /*!&lt; RCC APB1 peripheral clocks enable register 1,                            Address offset: 0x58 */\n  __IO uint32_t APB1ENR2;    /*!&lt; RCC APB1 peripheral clocks enable register 2,                            Address offset: 0x5C */\n  __IO uint32_t APB2ENR;     /*!&lt; RCC APB2 peripheral clocks enable register,                              Address offset: 0x60 */\n  uint32_t      RESERVED4;   /*!&lt; Reserved,                                                                Address offset: 0x64 */\n  __IO uint32_t AHB1SMENR;   /*!&lt; RCC AHB1 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x68 */\n  __IO uint32_t AHB2SMENR;   /*!&lt; RCC AHB2 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x6C */\n  __IO uint32_t AHB3SMENR;   /*!&lt; RCC AHB3 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x70 */\n  uint32_t      RESERVED5;   /*!&lt; Reserved,                                                                Address offset: 0x74 */\n  __IO uint32_t APB1SMENR1;  /*!&lt; RCC APB1 peripheral clocks enable in sleep mode and stop modes register 1, Address offset: 0x78 */\n  __IO uint32_t APB1SMENR2;  /*!&lt; RCC APB1 peripheral clocks enable in sleep mode and stop modes register 2, Address offset: 0x7C */\n  __IO uint32_t APB2SMENR;   /*!&lt; RCC APB2 peripheral clocks enable in sleep mode and stop modes register, Address offset: 0x80 */\n  uint32_t      RESERVED6;   /*!&lt; Reserved,                                                                Address offset: 0x84 */\n  __IO uint32_t CCIPR;       /*!&lt; RCC peripherals independent clock configuration register,                Address offset: 0x88 */\n  uint32_t      RESERVED7;   /*!&lt; Reserved,                                                                Address offset: 0x8C */\n  __IO uint32_t BDCR;        /*!&lt; RCC backup domain control register,                                      Address offset: 0x90 */\n  __IO uint32_t CSR;         /*!&lt; RCC clock control & status register,                                     Address offset: 0x94 */\n  __IO uint32_t CRRCR;       /*!&lt; RCC clock recovery RC register,                                          Address offset: 0x98 */\n} RCC_TypeDef;\n\n#define RCC ((RCC_TypeDef *) RCC_BASE)\n\n///////////////////////////////////////////////////////////////////////////////\n// Function prototypes\n///////////////////////////////////////////////////////////////////////////////\n\nvoid configurePLL(void);\nvoid configureClock(void);\n\n#endif"
  },
  {
    "objectID": "labs/lab4/lab4.html#rcc-c-file",
    "href": "labs/lab4/lab4.html#rcc-c-file",
    "title": "Lab 4",
    "section": "RCC C File ",
    "text": "RCC C File \n// STM32L432KC_RCC.c\n// Source code for RCC functions\n\n#include \"STM32L432KC_RCC.h\"\n\nvoid configurePLL(void) {\n    // Set clock to 80 MHz\n    // Output freq = (src_clk) * (N/M) / R\n    // (4 MHz) * (80/1) / 4 = 80 MHz\n    // M: 1, N: 80, R: 4\n    // Use MSI as PLLSRC\n\n    // Turn off PLL\n    RCC-&gt;CR &= ~(1 &lt;&lt; 24);\n    \n    // Wait till PLL is unlocked (e.g., off)\n    while ((RCC-&gt;CR &gt;&gt; 25 & 1) != 0);\n\n    // Load configuration\n    // Set PLL SRC to MSI\n    RCC-&gt;PLLCFGR |= (1 &lt;&lt; 0);\n    RCC-&gt;PLLCFGR &= ~(1 &lt;&lt; 1);\n\n    // Set PLLN\n    RCC-&gt;PLLCFGR &= ~(0b11111111 &lt;&lt; 8); // Clear all bits of PLLN\n    RCC-&gt;PLLCFGR |= (0b1010000 &lt;&lt; 8); // |= 80\n    \n    // Set PLLM\n    RCC-&gt;PLLCFGR &= ~(0b111 &lt;&lt; 4);  // Clear all bits\n    \n    // Set PLLR\n    RCC-&gt;PLLCFGR &= ~(1 &lt;&lt; 26);\n    RCC-&gt;PLLCFGR |= (1 &lt;&lt; 25);\n    \n    // Enable PLLR output\n    RCC-&gt;PLLCFGR |= (1 &lt;&lt; 24);\n\n    // Enable PLL\n    RCC-&gt;CR |= (1 &lt;&lt; 24);\n    \n    // Wait until PLL is locked\n    while ((RCC-&gt;CR &gt;&gt; 25 & 1) != 1);\n}\n\nvoid configureClock(void){\n    // Configure and turn on PLL\n    configurePLL();\n\n    // Select PLL as clock source\n    RCC-&gt;CFGR |= (0b11 &lt;&lt; 0);\n    while(!((RCC-&gt;CFGR &gt;&gt; 2) & 0b11));\n}"
  },
  {
    "objectID": "labs/lab4/lab4.html#tim-15-and-16-header",
    "href": "labs/lab4/lab4.html#tim-15-and-16-header",
    "title": "Lab 4",
    "section": "Tim 15 and 16 Header ",
    "text": "Tim 15 and 16 Header \n//STM32L432KC_TIM1516.h\n//Header for TIM1516 functions\n\n#ifndef STM32L4_TIM_15_16_H\n#define STM32L4_TIM_15_16_H\n\n#include &lt;stdint.h&gt;\n#include \"STM32L432KC_GPIO.h\" // Include GPIO header for GPIO type\n#define __IO volatile\n\n//Base Address\n#define TIM16_BASE (0x40014400UL)\n#define TIM15_BASE (0x40014000UL)\n\n//Bit Field\n\ntypedef struct{\n  __IO uint32_t CR1; //0x00\n  __IO uint32_t CR2; //0x04\n  __IO uint32_t SMCR; //0x08\n  __IO uint32_t DIER; //0x0C\n  __IO uint32_t SR; //0x10\n  __IO uint32_t EGR; //0x14\n  __IO uint32_t CCMR1; //0x18\n  __IO uint32_t BLANK; //0x1C\n  __IO uint32_t CCER; //0x20\n  __IO uint32_t CNT; //0x24\n  __IO uint32_t PSC; //0x028\n  __IO uint32_t ARR; //0x2C\n  __IO uint32_t RCR; //0x30\n  __IO uint32_t CCR1; //0x34\n  __IO uint32_t CCR2; //0x38\n  __IO uint32_t BLANK1; //0x3C\n  __IO uint32_t BLANK2; //0x40\n  __IO uint32_t BDTR; //0x44\n  __IO uint32_t DCR; //0x48\n  __IO uint32_t DMAR; //0x4C\n  __IO uint32_t OR1; //0x50\n  __IO uint32_t BLANK3; //0x54\n  __IO uint32_t BLANK4; //0x5C\n  __IO uint32_t OR2; //0x60\n} TIM_1516_Typedef;\n\n#define TIM15 ((TIM_1516_Typedef *) TIM15_BASE)\n#define TIM16 ((TIM_1516_Typedef *) TIM16_BASE)\n\nvoid initTIM(TIM_1516_Typedef* TIMx,uint32_t PSC_VAL);\nvoid delay_millis(TIM_1516_Typedef * TIM1x, TIM_1516_Typedef * TIM2x,uint32_t ms,uint32_t Frequency,GPIO* GPIOx,int pin);\nvoid PWM(TIM_1516_Typedef* TIMx, uint32_t Frequency);\n\n#endif"
  },
  {
    "objectID": "labs/lab4/lab4.html#tim-15-and-16-c-file",
    "href": "labs/lab4/lab4.html#tim-15-and-16-c-file",
    "title": "Lab 4",
    "section": "Tim 15 and 16 C File ",
    "text": "Tim 15 and 16 C File \n// STM32L432KC_TIM_15_16.c\n// Source code for TIM functions\n\n#include \"STM32L432KC_TIM_15_16.h\"\n#include \"STM32L432KC_RCC.h\"\n#include \"STM32L432KC_GPIO.h\"\n\nvoid initTIM(TIM_1516_Typedef * TIMx,uint32_t PSC_VAL) {\n    TIMx-&gt;CR1 |=(1&lt;&lt;7); // Turn on ARPE\n    TIMx-&gt;PSC = PSC_VAL; // Prescaler value (40 MHz / (799 + 1) = 50 kHz)\n}\n\nvoid delay_millis(TIM_1516_Typedef * TIM1x, TIM_1516_Typedef * TIM2x,uint32_t ms,uint32_t Frequency,GPIO* GPIOx,int pin) {\n    TIM1x-&gt;ARR = ms*100; // Auto-reload value for ms delay (50 kHz clock) for PSC 799\n    printf(\"ARR is %lu\\n\",TIM1x-&gt;ARR);\n    TIM1x-&gt;EGR |= (1&lt;&lt;0); // Generate an update event \n    TIM1x-&gt;SR &= ~(1&lt;&lt;0); // Clear interrupt flag\n    TIM1x-&gt;CR1 |= (1&lt;&lt;0); // Start timer\n\n    // Wait until the update interrupt flag is set\n    while (((TIM1x-&gt;SR &gt;&gt; 0) & 1) == 0){\n        if(Frequency!=0){\n            //printf(\"CNT is %lu, ARR is %lu\\n\",TIM2x-&gt;CNT,TIM2x-&gt;ARR);\n            if(TIM2x-&gt;CNT &lt; TIM2x-&gt;ARR/2){\n                digitalWrite(GPIOx,pin,GPIO_HIGH);\n            }\n            else{\n                digitalWrite(GPIOx,pin,GPIO_LOW);\n            }\n        }   \n        else{\n            digitalWrite(GPIOx,pin,GPIO_LOW);\n        }\n    };\n\n    TIM1x-&gt;CR1 &= ~(1&lt;&lt;0); // Stop the time\n}\n\n\nvoid PWM(TIM_1516_Typedef * TIMx, uint32_t Frequency) {\n    TIMx-&gt;ARR = (8000000/(Frequency)); // Auto-reload value for ms delay (50 kHz clock)\n    TIMx-&gt;EGR |= (1&lt;&lt;0); // Generate an update event \n    TIMx-&gt;SR &= ~(1&lt;&lt;0); // Clear interrupt flag\n    TIMx-&gt;CR1 |= (1&lt;&lt;0); // Start timer\n    printf(\"ARR is %lu\\n\",TIMx-&gt;ARR);\n    \n    \n\n    \n    \n\n\n}"
  },
  {
    "objectID": "labs/lab4/lab4.html#flash-header",
    "href": "labs/lab4/lab4.html#flash-header",
    "title": "Lab 4",
    "section": "Flash Header ",
    "text": "Flash Header \n// STM32L432KC_FLASH.h\n// Header for FLASH functions\n\n#ifndef STM32L4_FLASH_H\n#define STM32L4_FLASH_H\n\n#include &lt;stdint.h&gt;\n\n///////////////////////////////////////////////////////////////////////////////\n// Definitions\n///////////////////////////////////////////////////////////////////////////////\n\n#define __IO volatile\n\n// Base addresses for GPIO ports\n#define FLASH_BASE (0x40022000UL) // base address of RCC\n\n///////////////////////////////////////////////////////////////////////////////\n// Bitfield struct for GPIO\n///////////////////////////////////////////////////////////////////////////////\n\ntypedef struct {\n  __IO uint32_t ACR;      /*!&lt; FLASH access control register,   Address offset: 0x00 */\n  __IO uint32_t KEYR;     /*!&lt; FLASH key register,              Address offset: 0x04 */\n  __IO uint32_t OPTKEYR;  /*!&lt; FLASH option key register,       Address offset: 0x08 */\n  __IO uint32_t SR;       /*!&lt; FLASH status register,           Address offset: 0x0C */\n  __IO uint32_t CR;       /*!&lt; FLASH control register,          Address offset: 0x10 */\n  __IO uint32_t OPTCR;    /*!&lt; FLASH option control register ,  Address offset: 0x14 */\n  __IO uint32_t OPTCR1;   /*!&lt; FLASH option control register 1, Address offset: 0x18 */\n} FLASH_TypeDef;\n\n#define FLASH ((FLASH_TypeDef *) FLASH_BASE)\n\n///////////////////////////////////////////////////////////////////////////////\n// Function prototypes\n///////////////////////////////////////////////////////////////////////////////\n\nvoid configureFlash(void);\n\n#endif"
  },
  {
    "objectID": "labs/lab4/lab4.html#flash-c-file",
    "href": "labs/lab4/lab4.html#flash-c-file",
    "title": "Lab 4",
    "section": "Flash C File ",
    "text": "Flash C File \n// STM32L432KC_FLASH.c\n// Source code for FLASH functions\n\n#include \"STM32L432KC_FLASH.h\"\n\nvoid configureFlash(void) {\n    FLASH-&gt;ACR |= (0b100); // Set to 4 waitstates\n    FLASH-&gt;ACR |= (1 &lt;&lt; 8); // Turn on the ART\n}"
  },
  {
    "objectID": "labs/lab4/lab4.html#gpio-header",
    "href": "labs/lab4/lab4.html#gpio-header",
    "title": "Lab 4",
    "section": "GPIO Header ",
    "text": "GPIO Header \n// STM32L432KC_GPIO.h\n// Header for GPIO functions\n\n#ifndef STM32L4_GPIO_H\n#define STM32L4_GPIO_H\n\n#include &lt;stdint.h&gt; // Include stdint header\n\n///////////////////////////////////////////////////////////////////////////////\n// Definitions\n///////////////////////////////////////////////////////////////////////////////\n\n// Values for GPIO pins (\"val\" arguments)\n#define GPIO_LOW    0\n#define GPIO_HIGH   1\n\n// Base addresses for GPIO ports\n#define GPIOB_BASE  (0x48000400UL)\n#define GPIOA_BASE  (0x48000000UL)\n\n// Arbitrary GPIO functions for pinMode()\n#define GPIO_INPUT  0\n#define GPIO_OUTPUT 1\n#define GPIO_ALT    2\n#define GPIO_ANALOG 3\n\n///////////////////////////////////////////////////////////////////////////////\n// Bitfield struct for GPIO\n///////////////////////////////////////////////////////////////////////////////\n\n// GPIO register structs here\ntypedef struct {\n    volatile uint32_t MODER;   // GPIO Offset 0x00 GPIO port mode register\n    volatile uint32_t OTYPER;  // GPIO Offset 0x04\n    volatile uint32_t OSPEEDR; // GPIO Offset 0x08\n    volatile uint32_t PURPDR;  // GPIO Offset 0x0C\n    volatile uint32_t IDR;     // GPIO Offset 0x10\n    volatile uint32_t ODR;     // GPIO Offset 0x14\n    volatile uint32_t BSRR;    // GPIO Offset 0x18\n    volatile uint32_t LCKR;    // GPIO Offset 0x1C\n    volatile uint32_t AFRL;    // GPIO Offset 0x20\n    volatile uint32_t AFRH;    // GPIO Offset 0x24\n} GPIO;\n\n// Pointers to GPIO-sized chunks of memory for each peripheral\n#define GPIOB ((GPIO *) GPIOB_BASE)\n#define GPIOA ((GPIO *) GPIOA_BASE)\n//#define GPIO GPIOB\n\n///////////////////////////////////////////////////////////////////////////////\n// Function prototypes\n///////////////////////////////////////////////////////////////////////////////\n\nvoid pinMode(GPIO* GPIOx,int pin, int function);\n\nint digitalRead(GPIO* GPIOx,int pin);\n\nvoid digitalWrite(GPIO* GPIOx,int pin, int val);\n\nvoid togglePin(GPIO* GPIOx,int pin);\n\n#endif"
  },
  {
    "objectID": "labs/lab4/lab4.html#gpio-c",
    "href": "labs/lab4/lab4.html#gpio-c",
    "title": "Lab 4",
    "section": "GPIO C ",
    "text": "GPIO C \n// STM32L432KC_GPIO.c\n// Source code for GPIO functions\n\n#include \"STM32L432KC_GPIO.h\"\n\nvoid pinMode(GPIO* GPIOx,int pin, int function) {\n    switch(function) {\n        case GPIO_INPUT:\n            GPIOx-&gt;MODER &= ~(0b11 &lt;&lt; 2*pin);\n            break;\n        case GPIO_OUTPUT:\n            GPIOx-&gt;MODER |= (0b1 &lt;&lt; 2*pin);\n            GPIOx-&gt;MODER &= ~(0b1 &lt;&lt; (2*pin+1));\n            break;\n        case GPIO_ALT:\n            //sets moder\n            GPIOx-&gt;MODER &= ~(0b1 &lt;&lt; 2*pin);\n            GPIOx-&gt;MODER |= (0b1 &lt;&lt; (2*pin+1));\n            //sets as push pull\n            //GPIOx-&gt;OTYPER |= (0b1 &lt;&lt; pin); // Push-pull\n            GPIOx-&gt;AFRL |= (0b1110 &lt;&lt; 4*pin); // Clear bits\n            break;\n        case GPIO_ANALOG:\n            GPIOx-&gt;MODER |= (0b11 &lt;&lt; 2*pin);\n            break;\n    }\n}\n\nint digitalRead(GPIO* GPIOx,int pin) {\n    return ((GPIOx-&gt;IDR) &gt;&gt; pin) & 1;\n}\n\nvoid digitalWrite(GPIO* GPIOx,int pin, int val) {\n    if(val == GPIO_LOW)\n        GPIOx-&gt;ODR &= ~(1 &lt;&lt; pin);\n    else\n    GPIOx-&gt;ODR |= (1 &lt;&lt; pin);\n}\n\nvoid togglePin(GPIO* GPIOx,int pin) {\n    // Use XOR to toggle\n    GPIOx-&gt;ODR ^= (1 &lt;&lt; pin);\n}"
  },
  {
    "objectID": "labs/lab4/lab4.html#max-min-frequency",
    "href": "labs/lab4/lab4.html#max-min-frequency",
    "title": "Lab 4",
    "section": "Max Min Frequency ",
    "text": "Max Min Frequency \n ## Error   # Notes"
  },
  {
    "objectID": "labs/lab4/lab4.html#which-timers-can-you-use",
    "href": "labs/lab4/lab4.html#which-timers-can-you-use",
    "title": "Lab 4",
    "section": "1. Which timers can you use?",
    "text": "1. Which timers can you use?\nThe STM32L432KC has several general-purpose and advanced timers:\n\nTIM1 (advanced control, 16-bit, has complementary outputs, dead-time, etc.)\nTIM2 (general-purpose, 32-bit)\nTIM15, TIM16, TIM17 (16-bit, smaller general-purpose timers)\nLPTIM1, LPTIM2 (low-power timers, good for ultra-low-frequency and low-power applications, but less flexible for PWM).\n\n👉 For your use case (simple output waveforms at ~200 Hz–1 kHz):\n\nTIM2 is a great choice because it’s 32-bit, so you don’t need to worry about overflow.\nTIM1 or TIM15 are also good choices if you want direct PWM routing to GPIO pins with advanced features.\nIf you want the easiest connection to a GPIO pin, choose TIM2, TIM1, or TIM15, since they have well-documented alternate functions (AF) for output compare/PWM on pins."
  },
  {
    "objectID": "labs/lab4/lab4.html#how-do-you-generate-the-frequency",
    "href": "labs/lab4/lab4.html#how-do-you-generate-the-frequency",
    "title": "Lab 4",
    "section": "2. How do you generate the frequency?",
    "text": "2. How do you generate the frequency?\nA timer frequency is controlled by three things:\n[ f_{out} = ]\nWhere:\n\n(f_{TIM}) = timer clock frequency (depends on APB prescaler — typically up to 80 MHz on STM32L432).\nPSC = prescaler register (TIMx_PSC)\nARR = auto-reload register (TIMx_ARR) → sets the period.\n\nIf you want a PWM (toggle a pin), you set an output compare mode (via TIMx_CCMR) and choose a duty cycle using the capture/compare register (TIMx_CCRx)."
  },
  {
    "objectID": "labs/lab4/lab4.html#example-calculation",
    "href": "labs/lab4/lab4.html#example-calculation",
    "title": "Lab 4",
    "section": "3. Example Calculation",
    "text": "3. Example Calculation\nSuppose your system clock is 80 MHz and APB1 prescaler is 1 → so (f_{TIM} = 80 MHz).\nTarget frequency = 500 Hz.\n[ (PSC+1)(ARR+1) = = = 160{,}000]\nPick something convenient:\n\nPSC = 159 → (PSC+1) = 160\nARR = 999 → (ARR+1) = 1000 → Frequency = (80,MHz / (160 ) = 500,Hz).\n\nFor 220 Hz: [ (PSC+1)(ARR+1) = ] You might choose PSC = 359, ARR ≈ 1009 → ~220 Hz.\nFor 1 kHz: [ (PSC+1)(ARR+1) = = 80{,}000] PSC = 79, ARR = 999 → 1 kHz."
  },
  {
    "objectID": "labs/lab4/lab4.html#key-registers-to-configure",
    "href": "labs/lab4/lab4.html#key-registers-to-configure",
    "title": "Lab 4",
    "section": "4. Key Registers to Configure",
    "text": "4. Key Registers to Configure\n\nEnable clock to timer\n\nRCC_APB1ENR1 (for TIM2, TIM15, etc.)\nRCC_APB2ENR (for TIM1).\n\nSet prescaler\n\nTIMx_PSC = value.\n\nSet auto-reload register (period)\n\nTIMx_ARR = value.\n\nEnable output compare/PWM mode\n\nConfigure TIMx_CCMR1 (or CCMR2 depending on channel).\nSet channel to PWM mode 1 or 2.\n\nSet duty cycle\n\nTIMx_CCRx = value (between 0 and ARR).\n\nEnable output pin\n\nConfigure GPIO pin to AF mode with the right AF mapping for your chosen timer/channel.\nSet TIMx_CCER bit to enable the channel output.\n\nEnable counter\n\nSet TIMx_CR1.CEN = 1."
  },
  {
    "objectID": "labs/lab4/lab4.html#summary-recommendation",
    "href": "labs/lab4/lab4.html#summary-recommendation",
    "title": "Lab 4",
    "section": "5. Summary Recommendation",
    "text": "5. Summary Recommendation\n\nUse TIM2 if you want flexibility (32-bit, simple).\nUse TIM1 or TIM15 if you specifically want advanced PWM features (e.g., complementary outputs).\nConnect to GPIO via alternate function mapping (check STM32L432 datasheet for AF mappings).\n\n\n👉 If you’d like, I can write out a bare-metal register configuration example (C code) for, say, TIM2 CH1 on a specific GPIO pin (PA0), generating 500 Hz PWM. Do you want me to write out that code?"
  },
  {
    "objectID": "labs/lab4/lab4.html#ai-reflection",
    "href": "labs/lab4/lab4.html#ai-reflection",
    "title": "Lab 4",
    "section": "AI reflection",
    "text": "AI reflection\nThe AI response compared to my own decision making was very similar. We both Identified that Timmers 15 could directly connect to gpio pins. However it doesn’t mention timmers 6 and 7.\nThe equation it gave were semi useful but was better was the foot note explaining how to program the pwm using output compare mode.\nIt has the same logic path as mine. However the way it tries to go is directly output the pwm wave to gpio pin. They miss parts about setting the polarity for the output enabling gpio pins and clocks."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6",
    "section": "",
    "text": "Introduction\nSchematic\nC Code 3.1 Main C 3.2 Main Header 3.3 Start Up Code 3.4 Update Sensitivity 3.5 Update LED 3.6 In String 3.7 Webserver set up 3.8 SPI Header 3.9 SPI C 3.10 DS1722 Header 3.11 DS1722 C\nSample Spi Communication\nAI Prototype"
  },
  {
    "objectID": "labs/lab6/lab6.html#main-c",
    "href": "labs/lab6/lab6.html#main-c",
    "title": "Lab 6",
    "section": "Main C ",
    "text": "Main C \nint main(void) {\n    /*\n    File: main.c\n    Author: kanoa Parker\n    Email: kanoa.parker@hmc.edu\n    Date: 11/4/2025\n    Description: Code for STM32L432KC to read temperature data from DS1722 and display temperature on Webpage\n    */\n  startup();\n\n  USART_TypeDef * USART = initUSART(USART1_ID, 125000);\n  \n  volatile uint8_t sensitivity;\n  volatile float temperature;\n  volatile char tempstring[50];\n  volatile int led_status;\n  char ledStatusStr[20];\n  char sensitivitystatus[20];\n  set_sensitivity(0xe0);\n  \n  while(1) {\n    /* Wait for ESP8266 to send a request.\n    Requests take the form of '/REQ:&lt;tag&gt;\\n', with TAG begin &lt;= 10 characters.\n    Therefore the request[] array must be able to contain 18 characters.\n    */\n    \n    // Receive web request from the ESP\n    char request[BUFF_LEN] = \"                  \"; // initialize to known value\n    int charIndex = 0;\n  \n    // Keep going until you get end of line character\n    while(inString(request, \"\\n\") == -1) {\n      // Wait for a complete request to be transmitted before processing\n      while(!(USART-&gt;ISR & USART_ISR_RXNE));\n      request[charIndex++] = readChar(USART);\n    }\n    \n    //read temp\n    temperature = retrieve_temp();\n    //turns float to string\n    sprintf(tempstring, \"%f\",temperature);\n\n    // Update string with current LED state\n    led_status = updateLEDStatus(request, led_status);\n\n    \n    if (led_status == 1)\n      sprintf(ledStatusStr,\"LED is on!\");\n    else if (led_status == 0)\n      sprintf(ledStatusStr,\"LED is off!\");\n    \n    sensitivity = updateSensitivity(request, sensitivity);\n    set_sensitivity(sensitivity);\n\n    if(sensitivity == 0xe0)\n      sprintf(sensitivitystatus,\"8 bits\");\n    else if(sensitivity == 0xe2)\n      sprintf(sensitivitystatus,\"9 bits\");\n    else if(sensitivity == 0xe4)\n      sprintf(sensitivitystatus,\"10 bits\");\n    else if(sensitivity == 0xe6)\n      sprintf(sensitivitystatus,\"11 bits\");\n    else if(sensitivity == 0xe8)\n      sprintf(sensitivitystatus,\"12 bits\");\n\n    // finally, transmit the webpage over UART\n    sendString(USART, webpageStart); // webpage header code\n    sendString(USART, ledStr); // button for controlling LED\n\n    sendString(USART, \"&lt;h2&gt;LED Status&lt;/h2&gt;\");\n\n\n    sendString(USART, \"&lt;p&gt;\");\n    sendString(USART, ledStatusStr);\n    sendString(USART, \"&lt;/p&gt;\");\n    \n    sendString(USART,tempStr);\n    sendString(USART, \"&lt;p&gt;\");\n    sendString(USART, tempstring);\n    sendString(USART, \"Celsius &lt;/p&gt;\");\n    \n    sendString(USART, tempsensitivity);\n    sendString(USART, \"&lt;p&gt; Current sensitivity:\");\n    sendString(USART, sensitivitystatus);\n    sendString(USART, \"&lt;/p&gt;\");\n    sendString(USART, webpageEnd);\n    \n  }\nMain Module.\nLink to github with full list of library and header files. Link to Git Hub."
  },
  {
    "objectID": "labs/lab6/lab6.html#main-header",
    "href": "labs/lab6/lab6.html#main-header",
    "title": "Lab 6",
    "section": "Main Header ",
    "text": "Main Header \n/**\n    Main Header: Contains general defines and selected portions of CMSIS files\n    @file main.h\n    @author Kanoa parker\n    @email kanparker@hmc.edu\n    @date 11/4/2025\n*/\n\n#ifndef MAIN_H\n#define MAIN_H\n\n#include \"C:\\Users\\kanoa\\Documents\\hmc-e155\\lab\\lab06\\lib\\STM32L432KC.h\"\n\n#define LED_PIN PA8 // LED pin for blinking on Port B pin 3\n#define LED_PIN2 PA9\n#define BUFF_LEN 32\n\n#endif // MAIN_H"
  },
  {
    "objectID": "labs/lab6/lab6.html#startup",
    "href": "labs/lab6/lab6.html#startup",
    "title": "Lab 6",
    "section": "startup() ",
    "text": "startup() \nvoid startup(void){\n    ///startup code doing configurations\n  configureFlash();\n  configureClock();\n  gpioEnable(GPIO_PORT_A);\n  gpioEnable(GPIO_PORT_B);\n  gpioEnable(GPIO_PORT_C);\n  pinMode(LED_PIN, GPIO_OUTPUT);\n  RCC-&gt;APB2ENR |= (RCC_APB2ENR_TIM15EN);\n  initTIM(TIM15);\n  initSPI(0b101, 1, 1); // SPI clk = master clk / 64, CPOL = 1, CPHA = 1\n}\nInterupt handler for EXTI0 which is connected to the encoder signal A."
  },
  {
    "objectID": "labs/lab6/lab6.html#updatesensitivity",
    "href": "labs/lab6/lab6.html#updatesensitivity",
    "title": "Lab 6",
    "section": "updateSensitivity ",
    "text": "updateSensitivity \nuint8_t updateSensitivity(char request[],uint8_t current_sen)\n{       ///update sensitivity bits to be sent to DS1722 based on request from webserver\n        uint8_t sensitivity_status = current_sen;\n        if (inString(request, \"8b\")==1){\n          sensitivity_status= 0xe0;\n          //blinky();\n        }\n        else if (inString(request, \"9b\")==1){\n          sensitivity_status = 0xe2;\n          //blinky();\n        }\n        else if (inString(request, \"10b\")==1){\n          sensitivity_status = 0xe4;\n          //blinky();\n        }\n        else if (inString(request, \"11b\")==1){\n          sensitivity_status = 0xe6;\n          //blinky();\n        }\n        else if (inString(request, \"12b\")==1){\n          sensitivity_status = 0xe8;\n          //blinky();\n        }\n\n        return sensitivity_status;\n\n\n}\nInterupt handler for EXTI0 which is connected to the encoder signal A."
  },
  {
    "objectID": "labs/lab6/lab6.html#updateledstatus",
    "href": "labs/lab6/lab6.html#updateledstatus",
    "title": "Lab 6",
    "section": "updateLEDStatus",
    "text": "updateLEDStatus\nint updateLEDStatus(char request[], int current_status)\n{   ///updates led status based on webserver request\n    int led_status = current_status;\n    // The request has been received. now process to determine whether to turn the LED on or off\n    if (inString(request, \"ledoff\")==1) {\n        digitalWrite(LED_PIN, GPIO_LOW);\n        led_status = 0;\n    }\n    else if (inString(request, \"ledon\")==1) {\n        digitalWrite(LED_PIN, GPIO_HIGH);\n        led_status = 1;\n    }\n\n    return led_status;\n}"
  },
  {
    "objectID": "labs/lab6/lab6.html#instring",
    "href": "labs/lab6/lab6.html#instring",
    "title": "Lab 6",
    "section": "inString",
    "text": "inString\nint inString(char request[], char des[]) {\n    ///checks for if char is in request\n    if (strstr(request, des) != NULL) {return 1;}\n    return -1;\n}"
  },
  {
    "objectID": "labs/lab6/lab6.html#html-webpage-setup",
    "href": "labs/lab6/lab6.html#html-webpage-setup",
    "title": "Lab 6",
    "section": "HTML Webpage Setup ",
    "text": "HTML Webpage Setup \n//Defining the web page in two chunks: everything before the current time, and everything after the current time\nchar* webpageStart = \"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;E155 Web Server Demo Webpage&lt;/title&gt;\\\n    &lt;meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"&gt;\\\n    &lt;/head&gt;\\\n    &lt;body&gt;&lt;h1&gt;E155 Web Server Demo Webpage&lt;/h1&gt;\";\nchar* ledStr = \"&lt;p&gt;LED Control:&lt;/p&gt;&lt;form action=\\\"ledon\\\"&gt;&lt;input type=\\\"submit\\\" value=\\\"Turn the LED on!\\\"&gt;&lt;/form&gt;\\\n    &lt;form action=\\\"ledoff\\\"&gt;&lt;input type=\\\"submit\\\" value=\\\"Turn the LED off!\\\"&gt;&lt;/form&gt;\";\n//Defining Temperature Reading\nchar* tempStr = \"&lt;h2&gt; Temperature Sensor Reading:&lt;/h2&gt;\";\n//Form for temperature sensitivity\nchar* tempsensitivity = \"&lt;p&gt;Temperature Sensitivity Control&lt;/p&gt;&lt;form action= \\\"sensitivity\\\"&gt;\\\n  &lt;input type=\\\"radio\\\" id=\\\"8 bit\\\" name=\\\"fav\\\" value=\\\"8b\\\"&gt;\\\n  &lt;label for=\\\"8 bit\\\"&gt;8 bit&lt;/label&gt;&lt;br&gt;\\\n  &lt;input type=\\\"radio\\\" id=\\\"9 bit\\\" name=\\\"fav\\\" value=\\\"9b\\\"&gt;\\\n  &lt;label for=\\\"9 bit\\\"&gt;9 bit&lt;/label&gt;&lt;br&gt;\\\n  &lt;input type=\\\"radio\\\" id=\\\"10 bit\\\" name=\\\"fav\\\" value=\\\"10b\\\"&gt;\\\n  &lt;label for=\\\"10 bit\\\"&gt;10 bit&lt;/label&gt;&lt;br&gt;\\\n  &lt;input type=\\\"radio\\\" id=\\\"11 bit\\\" name=\\\"fav\\\" value=\\\"11b\\\"&gt;\\\n  &lt;label for=\\\"11 bit\\\"&gt;11 bit&lt;/label&gt;&lt;br&gt;\\\n  &lt;input type=\\\"radio\\\" id=\\\"12 bit\\\" name=\\\"fav\\\" value=\\\"12b\\\"&gt;\\\n  &lt;label for=\\\"12 bit\\\"&gt;12 bit&lt;/label&gt;&lt;br&gt;\\\n  &lt;input type=\\\"submit\\\" value=\\\"Submit\\\"&gt;\\\n  &lt;/form&gt;\";\nchar* webpageEnd   = \"&lt;/body&gt;&lt;/html&gt;\";"
  },
  {
    "objectID": "labs/lab6/lab6.html#spi-header",
    "href": "labs/lab6/lab6.html#spi-header",
    "title": "Lab 6",
    "section": "SPI Header ",
    "text": "SPI Header \n// STM32L432KC_SPI.h\n// TODO: Kanoa Parker\n//kanparker@hmc.edu\n// 11/4/2025\n//SPI header file\n\n#ifndef STM32L4_SPI_H\n#define STM32L4_SPI_H\n\n#include &lt;stdint.h&gt;\n#include &lt;stm32l432xx.h&gt;\n\n///////////////////////////////////////////////////////////////////////////////\n// Function prototypes\n///////////////////////////////////////////////////////////////////////////////\n\n/* Enables the SPI peripheral and intializes its clock speed (baud rate), polarity, and phase.\n *    -- br: (0b000 - 0b111). The SPI clk will be the master clock / 2^(BR+1).\n *    -- cpol: clock polarity (0: inactive state is logical 0, 1: inactive state is logical 1).\n *    -- cpha: clock phase (0: data captured on leading edge of clk and changed on next edge, \n *          1: data changed on leading edge of clk and captured on next edge)\n * Refer to the datasheet for more low-level details. */ \nvoid initSPI(int br, int cpol, int cpha);\n\n/* Transmits a character (1 byte) over SPI and returns the received character.\n *    -- send: the character to send over SPI\n *    -- return: the character received over SPI */\nchar spiSendReceive(char send);\n    \n#endif"
  },
  {
    "objectID": "labs/lab6/lab6.html#spi-c-file",
    "href": "labs/lab6/lab6.html#spi-c-file",
    "title": "Lab 6",
    "section": "SPI C File ",
    "text": "SPI C File \n// STM32L432KC_SPI.c\n// TODO: Kanoa Parker\n// TODO: kanparker@hmc.edu\n// TODO: 11/4/2025\n// TODO: SPI C files to send and recieve data\n\n#include \"STM32L432KC.h\"\n#include \"STM32L432KC_SPI.h\"\n#include \"STM32L432KC_RCC.h\"\n#include \"STM32L432KC_GPIO.h\"\n\nvoid initSPI(int br, int cpol, int cpha){\n    // Enable SPI1 clock\n    RCC-&gt;APB2ENR |= RCC_APB2ENR_SPI1EN;\n    RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOAEN;\n    RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOBEN; // Enable GPIOA clock for SPI1 pins\n    \n    // Configure GPIO pins for SPI1\n    pinMode(PB3, GPIO_ALT); // SCK\n    pinMode(PB4, GPIO_ALT); // MISO\n    pinMode(PB5, GPIO_ALT); // MOSI\n    pinMode(PB1, GPIO_OUTPUT); // CE\n\n    //Set alternate function to AF5 (SPI1)\n    GPIOB-&gt;AFR[0] |= _VAL2FLD(GPIO_AFRL_AFSEL3, 5);\n    GPIOB-&gt;AFR[0] |= _VAL2FLD(GPIO_AFRL_AFSEL4, 5);\n    GPIOB-&gt;AFR[0] |= _VAL2FLD(GPIO_AFRL_AFSEL5, 5);\n    \n    GPIOB -&gt;OSPEEDR |= (GPIO_OSPEEDR_OSPEED3); // Set PA5 speed to high\n    // Configure SPI1\n    SPI1-&gt;CR1 = 0; // Reset CR1 register\n    \n    // Set baud rate, clock polarity, and clock phase\n    SPI1-&gt;CR1 &= ~(SPI_CR1_CPOL | SPI_CR1_CPHA | SPI_CR1_LSBFIRST | SPI_CR1_SSM);\n    SPI1-&gt;CR1 |= _VAL2FLD(SPI_CR1_BR, br);\n    SPI1-&gt;CR1 |= _VAL2FLD(SPI_CR1_CPOL, cpol);\n    SPI1-&gt;CR1 |= _VAL2FLD(SPI_CR1_CPHA, cpha);\n\n    // Set as Master,\n    SPI1-&gt;CR1 |= _VAL2FLD(SPI_CR1_MSTR,1); \n\n    // Set data frame format to 8 bits\n    SPI1-&gt;CR2 |= _VAL2FLD(SPI_CR2_DS,0b0111);\n\n    SPI1-&gt;CR2 |= (SPI_CR2_FRXTH); // Set RXNE threshold to 8 bits\n    SPI1-&gt;CR2 |= (SPI_CR2_SSOE); // Enable SS output\n\n    // Enable SPI\n    SPI1-&gt;CR1 |= SPI_CR1_SPE;\n\n\n}\n\nchar spiSendReceive(char send){\n    // Wait until TXE (Transmit buffer empty) flag is set\n    while(!(SPI1-&gt;SR & SPI_SR_TXE));\n    // Send data\n    *(volatile uint8_t *) (&SPI1-&gt;DR) = send;\n    \n    // Wait until RXNE (Receive buffer not empty) flag is set\n    while(!(SPI1-&gt;SR & SPI_SR_RXNE));\n    // Read and return received data\n    char readval = (volatile char) SPI1-&gt;DR;\n    return readval;\n}"
  },
  {
    "objectID": "labs/lab6/lab6.html#ds1722-header",
    "href": "labs/lab6/lab6.html#ds1722-header",
    "title": "Lab 6",
    "section": "DS1722 Header ",
    "text": "DS1722 Header \n// DS1722.h\n// TODO: Kanoa Parker\n// TODO: kanparker@g.hmc.edu\n// TODO: 11/3/2025\n// TODO: Modules for setting temperature sensitivity and extracting temperature data from DS1722\n\n#ifndef STM32L4_DS1722_H\n#define STM32L4_DS1722_H\n\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stm32l432xx.h&gt;\n#include \"STM32L432KC_GPIO.h\"\n\n\n\nfloat retrieve_temp(void);\n\nvoid set_sensitivity(uint8_t sensitivity);\n#endif"
  },
  {
    "objectID": "labs/lab6/lab6.html#ds1722-c",
    "href": "labs/lab6/lab6.html#ds1722-c",
    "title": "Lab 6",
    "section": "DS1722 C ",
    "text": "DS1722 C \n// DS1722.c\n// TODO: Kanoa Parker\n// TODO: kanparker@g.hmc.edu\n// TODO: 11/3/2025\n// TODO: Modules for setting temperature sensitivity and extracting temperature data from DS1722\n\n#include \"STM32L432KC_GPIO.h\"\n#include \"STM32L432KC_SPI.h\"\n#include \"DS1722.h\"\n\n\nfloat retrieve_temp(void){\n    volatile uint16_t temp_reading;\n    volatile uint8_t temp_reading2;\n    volatile uint8_t sensitivity;\n    volatile float temperature;\n    //volatile char tempstring[50];\n\n    digitalWrite(PB1,GPIO_HIGH);\n    spiSendReceive(0x02); //First half of bits address\n    temp_reading = spiSendReceive(0x50);\n    digitalWrite(PB1,GPIO_LOW);\n    //printf(\"First Half of Bits is %d\\n\",temp_reading);\n    \n    digitalWrite(PB1,GPIO_HIGH);\n    spiSendReceive(0x01);\n    temp_reading2 = spiSendReceive(0x50); //Second half of bits\n    digitalWrite(PB1,GPIO_LOW);\n    //printf(\"Second half of bits %d\\n\",temp_reading2);\n    \n    temp_reading = ((uint16_t)(temp_reading)&lt;&lt;8 | temp_reading2);\n    temp_reading = (float)(temp_reading);\n    temperature = temp_reading/256.0;\n    //printf(\"The temperature is: %f\\n\",temperature);\n    //sprintf(tempstring, \"%f\",temperature);\n    return temperature;\n}\n\nvoid set_sensitivity(uint8_t sensitivity){\n    digitalWrite(PB1,GPIO_HIGH);\n    spiSendReceive(0x80);  \n    spiSendReceive(sensitivity);\n    digitalWrite(PB1,GPIO_LOW);\n}"
  },
  {
    "objectID": "labs/lab6/lab6.html#respone-from-chatgpt-html-code-and-rendered-code",
    "href": "labs/lab6/lab6.html#respone-from-chatgpt-html-code-and-rendered-code",
    "title": "Lab 6",
    "section": "Respone from Chatgpt HTML Code and rendered code",
    "text": "Respone from Chatgpt HTML Code and rendered code\n\n\n\nRendered Website\n\n\nDone — I created a single-file HTML page titled temperature-portal.html in the canvas (you can open it on the right).\nWhat’s included\nClean, responsive UI with modern dark theme and accessible controls.\nBig live temperature readout (with unit) and a small sparkline showing recent history.\nPrecision selector (0–3 decimals).\nLED control with animated indicator and buttons (sends via WebSocket if connected, falls back to POST /api/led).\nWebSocket connection input (editable) and Connect / Disconnect buttons.\nDemo mode to simulate sensor data if you don’t have a backend.\nBasic logs panel and keyboard shortcut (Space toggles demo).\nHow to hook it up\nEdit the WebSocket URL in the “Connection” field (default ws://localhost:8080) and click Apply URL then Connect. WebSocket messages should be JSON like:\n{ “sensorId”: “your-id”, “temp”: 23.12, “unit”: “°C” }\nIf you prefer HTTP polling, implement GET /api/temperature that returns { “temp”: 23.12, “unit”: “°C” }. The page polls that endpoint every ~1.5s when not using WebSocket.\nLED: WebSocket will receive { “led”: true } when user toggles; otherwise the page attempts POST /api/led with {“led”: true}.\nIf you want, I can:\nConvert this into a React component/page (single-file) with Tailwind.\nAdd authentication headers or an API-key flow.\nWire up MQTT instead of WebSocket, or adapt payload formats.\nTell me which of those (or anything else) you want next and I’ll update the file directly."
  },
  {
    "objectID": "labs/lab6/lab6.html#temperature-c-code",
    "href": "labs/lab6/lab6.html#temperature-c-code",
    "title": "Lab 6",
    "section": "Temperature C Code",
    "text": "Temperature C Code\nHere’s a clean and robust example of a C function that uses CMSIS (and STM32 HAL-style register access) to perform a SPI transaction and retrieve the temperature reading from a DS1722 digital thermometer on an STM32L432KC.\n\n\n🧠 Background\n\nThe DS1722 uses an SPI interface (Mode 3: CPOL=1, CPHA=1).\nTo read temperature, you issue a Read Temperature MSB command (0x02) and optionally the Read LSB command (0x01) after it, depending on resolution.\nEach register read is one byte, MSB first.\nThe temperature register is 16-bit, left-justified.\n\n\n\n\n✅ Example Function\n#include \"stm32l4xx.h\"  // CMSIS header for STM32L4 series\n#include &lt;stdint.h&gt;\n\n// DS1722 Register addresses\n#define DS1722_REG_TEMP_MSB  0x02\n#define DS1722_REG_TEMP_LSB  0x01\n\n// SPI chip select macros\n#define DS1722_CS_LOW()   (GPIOA-&gt;BSRR = (uint32_t)(1 &lt;&lt; (4 + 16)))  // e.g., PA4 low\n#define DS1722_CS_HIGH()  (GPIOA-&gt;BSRR = (uint32_t)(1 &lt;&lt; 4))         // PA4 high\n\n// === Function: SPI Transfer (single byte) ===\nstatic uint8_t SPI_TransferByte(SPI_TypeDef *SPIx, uint8_t data)\n{\n    while (!(SPIx-&gt;SR & SPI_SR_TXE));     // Wait until TX buffer empty\n    *((__IO uint8_t *)&SPIx-&gt;DR) = data;  // Write data to SPI data register\n    while (!(SPIx-&gt;SR & SPI_SR_RXNE));    // Wait until RX buffer not empty\n    return *((__IO uint8_t *)&SPIx-&gt;DR);  // Read received data\n}\n\n// === Function: Read Temperature ===\nfloat DS1722_ReadTemperature(SPI_TypeDef *SPIx)\n{\n    uint8_t msb, lsb;\n    uint16_t raw;\n    float temperature;\n\n    DS1722_CS_LOW();\n\n    // Read MSB\n    SPI_TransferByte(SPIx, DS1722_REG_TEMP_MSB);  // Send command\n    msb = SPI_TransferByte(SPIx, 0x00);           // Dummy write to read\n\n    // Read LSB (optional for higher resolution)\n    SPI_TransferByte(SPIx, DS1722_REG_TEMP_LSB);\n    lsb = SPI_TransferByte(SPIx, 0x00);\n\n    DS1722_CS_HIGH();\n\n    // Combine bytes (MSB: bits 15–8, LSB: bits 7–0)\n    raw = ((uint16_t)msb &lt;&lt; 8) | lsb;\n\n    // Convert to °C\n    // DS1722 uses 0.5°C per bit in 9-bit mode, or 0.0625°C/bit in 12-bit mode.\n    // Assume 12-bit mode by default.\n    temperature = (raw &gt;&gt; 4) * 0.0625f;\n\n    return temperature;\n}\n\n\n\n⚙️ Setup Notes\n\nSPI Configuration\n// Example: SPI1 on STM32L432KC\nRCC-&gt;APB2ENR |= RCC_APB2ENR_SPI1EN;\nRCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOAEN;\n\n// SPI1 pins: PA5=SCK, PA6=MISO, PA7=MOSI, PA4=CS\nGPIOA-&gt;MODER &= ~(GPIO_MODER_MODE4_Msk | GPIO_MODER_MODE5_Msk |\n                  GPIO_MODER_MODE6_Msk | GPIO_MODER_MODE7_Msk);\nGPIOA-&gt;MODER |= (1U &lt;&lt; GPIO_MODER_MODE5_Pos) | (1U &lt;&lt; GPIO_MODER_MODE6_Pos) | (1U &lt;&lt; GPIO_MODER_MODE7_Pos); // AF mode\nGPIOA-&gt;AFR[0] |= (5 &lt;&lt; (5*4)) | (5 &lt;&lt; (6*4)) | (5 &lt;&lt; (7*4)); // AF5 for SPI1\nGPIOA-&gt;MODER |= (1U &lt;&lt; GPIO_MODER_MODE4_Pos); // CS as output\nDS1722_CS_HIGH();\n\nSPI1-&gt;CR1 = SPI_CR1_MSTR | SPI_CR1_SSM | SPI_CR1_SSI |\n            SPI_CR1_CPOL | SPI_CR1_CPHA | SPI_CR1_BR_1; // Mode 3, Master, SSM\nSPI1-&gt;CR1 |= SPI_CR1_SPE; // Enable SPI\nCall Example\nfloat temp = DS1722_ReadTemperature(SPI1);\nprintf(\"Temperature: %.2f °C\\\\n\", temp);\n\n\n\n\n🧩 Optional Enhancements\n\nAdd error checking (e.g., SPI timeout).\nHandle precision configuration (DS1722 allows setting resolution in config register 0x0A).\nWrap SPI init and read in FreeRTOS-safe critical sections if multitasking.\n\n\nWould you like me to extend this so it initializes the DS1722 (sets continuous conversion and precision) before reading temperature? That would make it fully ready for embedded use."
  },
  {
    "objectID": "labs/lab6/lab6.html#reflection",
    "href": "labs/lab6/lab6.html#reflection",
    "title": "Lab 6",
    "section": "Reflection",
    "text": "Reflection\nFor the website presonally I think it is really clean. The colors are a good contrast between the blue and the whie and the Temperature reading is nice and big so it is easy to see for the user. They have for the led on and off they have a rendered led which is visually very helpful. The precision is converted from bits to decimal which is more understandable for users. It has a bunch of other little features like last time update and a debug log at the bottom making it easier to fix. However when I tried to render it on my ESP8266 through the MCU the site would not render because I couldn’t even build it. The direct copy and paste was not viable because the formatting into char was a little different from what chat gave me.\nFor the C code provided by Chat GPT it was overall pretty good. However it doesn’t utilize a lot of preexisting libraries that I have. For example doing all the GPIO pin enables it is doing direct bit manipulation making it a little difficult to understand. IT forgets to do a few specific things such as seting RXNE threshold to 8 bits and enabling SS output. It doesn’t set hte frame format to 8 bits. For the temperature reading its overal really solid. It doesn’t declare any of the variables as volatile which is annoying. The way it converts from binay to float is also a little concerning. It does it differntly by then shifting the combined number back which does make sense but it assumes 12 bit resolution. The code doesn’t compile because there is some sort of syntax error involving a paranthesis."
  },
  {
    "objectID": "labss.html",
    "href": "labss.html",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab 1\n\n\nProgramming a Seven Segment display and 3 LEDs with Combinational Logic\n\n\n\n\n\nSep 2, 2025\n\n\nKanoa Parker\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2\n\n\nProgramming a Dual Seven Segment display controlled by 2 sets of 4 dipswitches. Using a time multiplexer the inputs from four switches control one half of the display. In addition 5 leds indicate the sum of the two sets of 4 dip switches.\n\n\n\n\n\nSep 9, 2025\n\n\nKanoa Parker\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3\n\n\nLab 3\n\n\n\n\n\nAug 29, 205\n\n\nKanoa Parker\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4\n\n\nProgramming a STM32L432KC Microcontroller to output a PWM wave at specific freqeuncies and at specific durations in order to drive a speaker.\n\n\n\n\n\nSep 30, 2025\n\n\nKanoa Parker\n\n\n\n\n\n\n\n\n\n\n\n\nLab 5\n\n\nProgramming a STM32L432KC Microcontroller to read pulses from a motor encoder and interpreting those waves as interupts in order to calculate rotation speed.\n\n\n\n\n\nOct 7, 2025\n\n\nKanoa Parker\n\n\n\n\n\n\n\n\n\n\n\n\nLab 6\n\n\nProgramming a STM32L432KC Microcontroller to read temperature from a DS1722 and Display readings on a ESP8266 Webserver.\n\n\n\n\n\nNov 4, 205\n\n\nKanoa Parker\n\n\n\n\n\n\n\n\n\n\n\n\nLab 7\n\n\nLab 7\n\n\n\n\n\nAug 29, 205\n\n\nKanoa Parker\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "project/project_final_report/project_final_report.html",
    "href": "project/project_final_report/project_final_report.html",
    "title": "E155 Final Report: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "Our final project was to design and build a digital guitar amplifier capable of producing 4 audio effects: distortion, reverb, vibrato, and chorus. Using an iCE 40UP5K FPGA and an MCP3202 ADC, we sample our guitar output and perform all effects related to time-delay. An STM32L432KC microcontroller performs all modifications that change the amplitude of our signal in a non-linear way as well as converting our digital signal back to an analog one before recentering and playing our signal.\n\n\n\n\n\nLughnasa Miller is a senior Computer Science major at Harvey Mudd College. She focuses her studies in computer science at the system level, learning about the interaction between low level code and system components and creating embedded systems to solve problems. Outside of the classroom, you can find her playing one of the seven instruments she has learned or organizing queer community through the PRISM club and other engagements. Lughnasa can be found on GitHub as well as LinkedIn.\n\n\n\nKanoa is a Senior at Harvey Mudd College, born and raised in Los Angeles, CA. His passions are in Automotive Engineering, and 3D Design. Currently, he is an active member of Claremont College’s Men’s Rugby Team. In his leisure time, he enjoys hiking, camping, vegetarian cooking, and pursuing creative endeavors in wood carving and model building. Kanoa can be found on GitHub as well as LinkedIn.\n\n\n\n\nThe FPGA aimed to communicate with an ADC over a serial communication protocol, enabling it to read in a 12-bit serial analog signal. This information will be stored in the FPGA memory blocks before being read out at various times to implement delay based effects in our sound.\nTwo main halves of this system were ideated and implemented: a controller SPI communication module for interfacing with the ADC chip purchased for this project, as well as a memory for storing samples and loading into a shift register that interfaced with our STM32L432KC processor as a peripheral to the MCU’s SPI communications. The full details of the digital design can be interpreted in the block diagram shown below.\n Figure 1: Block diagram of the FPGA implementation\nThe ADC SPI module implemented a shift register to record input from the ADC and utilized an FSM that controlled the FPGA’s SDO bit as well as asserting signals to the memory when a sample was ready to be stored. The datapath contained an FSM that controlled when memory was read and the current address in memory was implemented, and there was a specially designed shift register that functioned on either the FPGA or MCU clock in order to both load and empty the register.\n\n\n\nIn this project, the MCU will take data over SPI communications from the FPGA. After this, the MCU will determine whether a distortion and/or vibrato effect should be applied to the signal. It will apply the relevant transformations, and then it will use the onboard DAC to convert back to an analog signal before outputting to a \\(\\frac{1}{4}\\) in. audio jack which drives a small guitar amp.\n\n\n\nIn this project, we aimed to implement an ADC that was interfaced with by the FPGA. This allowed us to use the MCU’s onboard DAC to complete a full datapath and enabled us to not circle back, having to send signals back and forth between the MCU and FPGA. This challenged us in a number of ways, including designing an FSM on the FPGA capable of sending the proper initiation bits to read a signal as well as learning how to synchronize this design with the rest of our datapath.\n\n\n\nBelow is the surrounding electrical schematic. On the rx chain, filtering was implemented to clean out signal before moving it from an ~ 100 mVAC signal to a 0-3.3 VDC signal that is acceptable for digital interfacing. At the other end of the system, after the MCU’s DAC, these operations were inverted so our signal once again mimicked that of a standard guitar. Below, a schematic of our electrical system can be seen.\n Figure 2: Full surrounding electrical schematic for signal voltage adjustment\n\n\n\nBelow is a figure detailing the bill of materials used in this project.\n\n\n\nCategory\nProduct\nPart Number\nUnit Price\nQTY\nTotal+Tax\nDatasheet/Link\n\n\n\n\n\n\n\n\n\n\n\n\n\nDual Rail Op Amp\nOP07 Ultralow Offset VoltageOperational Amplifier\nOP07CPZ-ND\nStock Room\n2\n0\nhttps://www.analog.com/media/en/technical-documentation/data-sheets/op07.pdf\n\n\nSingle Rail Op Amp\nMCP601-I/P\nMCP601-I/P-ND\nStock Room\n0\n0\nhttps://ww1.microchip.com/downloads/en/DeviceDoc/21314g.pdf\n\n\nAudio Input Jack\nLOCHSOEL 6.35mm (1/4inch) Female Stereo Socket Panel Mount Jacks, Pack of 6\nACJM-MN-2\n1.55\n3\n4.65\nhttps://www.amphenol-sine.com/pdf/catalog/CAT-AUDIO.pdf\n\n\nADC Options\nMCP3202-CI/P\nMCP3202-CI/P-ND\n$1.66\n5\n$8.30\nhttps://ww1.microchip.com/downloads/aemDocuments/documents/APID/ProductDocuments/DataSheets/21034F.pdf\n\n\nToggle Switch\nCARLING TECHNOLOGIES Toggle Switch: 3 Position, 6 Connections, DPDT, G Series\n2GM51 - 73\n0\n4\n0\nhttps://www.grainger.com/ec/pdf/G-SeriesSW_Details_26_COS__EHSU_v1.pdf\n\n\nResistors\n100 K Ω Resistor\nNA\nStock Room\n0\n0\n\n\n\nPotentiometer\n100 K Ω Potentiometer\nNA\nStock Room\n0\n0\n\n\n\n\n\n\n\n\n\n\n\n\nTotal Cost\n12.95\n\n\n\n\n\n\n\n\nFigure 3: Bill of materials detailing materials aquired for use in this project\n\n\n\nIn our project, we were unable to achieve the goals we had set for our FPGA design. A major roadblock for us was interfacing the ADC with the FPGA. This error was very confusing with us, as communication over SPI was intermmittent and unstable, but did work occasionally. Too late in our project, we realized that the sampling rate that we wanted to achieve with our FPGA architecture was not compatible with the ADC we had purchased. As a result, we had to modify our clock tree and sampling rate previously designed.\nAnother major roadblock we navigated was loading the shift register for the MCU to read samples from the FPGA. This happened because the FPGA ran on its own clock domain, and the MCU ran its SPI transactions on a separate clock that ran approximately 500 MHz faster than that on the FPGA. However, this roadbock was successfully navigated and can be seen in the following section.\nThe MCU systems we aimed to implement worked well on their own. The first major piece of our design was the SPI communications between the MCU and the FPGA. By looking at the digital trace of these communications below, we can see that the MCU successfully retrieved a sample from the FPGA.\n Figure 4: FPGA to MCU SPI transaction\nThe next step was for the MCU to use the onboard DAC to process a clean signal and send it through our postprocessing chain. This was done in the image seen below using a sample frequency, indicating that we were capable of outputting a known voltage.\n Figure 5: Clean MCU output wave trace\nFinally, we implemented the distortion effect, which functions by clipping the edges of our signal range to make our audio waves more square. This gives the audio a distorted effect, which can be seen in songs as early as Voodoo Child (Slight Return) by Jimi Hendrix. Below is an oscilloscope trace conveying a working distortion signal using sample data.\n Figure 6: MCU output wave trace with distortion\n\n\n\nOverall, our team learned a lot in the experience of completing the project, even if we did not achieve the final goal of creating a functional guitar pedal. We definitely undersold ourselves on the amount of time we would need to complete our project, and it ended up being the nail in the coffin for our group. However, we did learn valuable lessons in reading our datasheets and learning specific SPI protocols. We also gained valuable experience in designing clock domains with synchrony across multiple clocks, which was a difficult but valuable achievement for us in the later stages of our project.\nWe also think that the architecture for our project was very solid, and the various components for the project were ones we feel were right for the job. Given a few more days, we believe we could have bugfixed the commnunications between the ADC and FPGA, which would have processed a clean sample for us. Following this, we would have been able to complete modifications to the FPGA datapath that would have allowed averaging of past samples to enable reverb and chorus effects. Finally, enabling the RNG peripheral on the MCU would have given us a method for implementing the vibrato effect on the signal, completing our fourth and final effect, and the total goal for our project.\n\n\n\nWe want to thank Prof. Spencer, Javier, and the E155 grutoring team for their guidance and advice as we went along the path of this project. We also want to thank engineering staff as a whole for their support, especially in the final push of the project and in aquiring the materials necessary to complete the project.\n\n\n\nSTM32L432KC Documentation and Reference Manual\nICE40UP5K Family Datasheet\nMicrochip MCP3202 ADC Documentation\nGitHub Project Repository"
  },
  {
    "objectID": "project/project_final_report/project_final_report.html#description",
    "href": "project/project_final_report/project_final_report.html#description",
    "title": "E155 Final Report: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "Our final project was to design and build a digital guitar amplifier capable of producing 4 audio effects: distortion, reverb, vibrato, and chorus. Using an iCE 40UP5K FPGA and an MCP3202 ADC, we sample our guitar output and perform all effects related to time-delay. An STM32L432KC microcontroller performs all modifications that change the amplitude of our signal in a non-linear way as well as converting our digital signal back to an analog one before recentering and playing our signal."
  },
  {
    "objectID": "project/project_final_report/project_final_report.html#biographies",
    "href": "project/project_final_report/project_final_report.html#biographies",
    "title": "E155 Final Report: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "Lughnasa Miller is a senior Computer Science major at Harvey Mudd College. She focuses her studies in computer science at the system level, learning about the interaction between low level code and system components and creating embedded systems to solve problems. Outside of the classroom, you can find her playing one of the seven instruments she has learned or organizing queer community through the PRISM club and other engagements. Lughnasa can be found on GitHub as well as LinkedIn.\n\n\n\nKanoa is a Senior at Harvey Mudd College, born and raised in Los Angeles, CA. His passions are in Automotive Engineering, and 3D Design. Currently, he is an active member of Claremont College’s Men’s Rugby Team. In his leisure time, he enjoys hiking, camping, vegetarian cooking, and pursuing creative endeavors in wood carving and model building. Kanoa can be found on GitHub as well as LinkedIn."
  },
  {
    "objectID": "project/project_final_report/project_final_report.html#fpga-design-information",
    "href": "project/project_final_report/project_final_report.html#fpga-design-information",
    "title": "E155 Final Report: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "The FPGA aimed to communicate with an ADC over a serial communication protocol, enabling it to read in a 12-bit serial analog signal. This information will be stored in the FPGA memory blocks before being read out at various times to implement delay based effects in our sound.\nTwo main halves of this system were ideated and implemented: a controller SPI communication module for interfacing with the ADC chip purchased for this project, as well as a memory for storing samples and loading into a shift register that interfaced with our STM32L432KC processor as a peripheral to the MCU’s SPI communications. The full details of the digital design can be interpreted in the block diagram shown below.\n Figure 1: Block diagram of the FPGA implementation\nThe ADC SPI module implemented a shift register to record input from the ADC and utilized an FSM that controlled the FPGA’s SDO bit as well as asserting signals to the memory when a sample was ready to be stored. The datapath contained an FSM that controlled when memory was read and the current address in memory was implemented, and there was a specially designed shift register that functioned on either the FPGA or MCU clock in order to both load and empty the register."
  },
  {
    "objectID": "project/project_final_report/project_final_report.html#mcu-design-information",
    "href": "project/project_final_report/project_final_report.html#mcu-design-information",
    "title": "E155 Final Report: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "In this project, the MCU will take data over SPI communications from the FPGA. After this, the MCU will determine whether a distortion and/or vibrato effect should be applied to the signal. It will apply the relevant transformations, and then it will use the onboard DAC to convert back to an analog signal before outputting to a \\(\\frac{1}{4}\\) in. audio jack which drives a small guitar amp."
  },
  {
    "objectID": "project/project_final_report/project_final_report.html#new-digital-chip-microchip-mcp3202-adc",
    "href": "project/project_final_report/project_final_report.html#new-digital-chip-microchip-mcp3202-adc",
    "title": "E155 Final Report: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "In this project, we aimed to implement an ADC that was interfaced with by the FPGA. This allowed us to use the MCU’s onboard DAC to complete a full datapath and enabled us to not circle back, having to send signals back and forth between the MCU and FPGA. This challenged us in a number of ways, including designing an FSM on the FPGA capable of sending the proper initiation bits to read a signal as well as learning how to synchronize this design with the rest of our datapath."
  },
  {
    "objectID": "project/project_final_report/project_final_report.html#electrical-schematic",
    "href": "project/project_final_report/project_final_report.html#electrical-schematic",
    "title": "E155 Final Report: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "Below is the surrounding electrical schematic. On the rx chain, filtering was implemented to clean out signal before moving it from an ~ 100 mVAC signal to a 0-3.3 VDC signal that is acceptable for digital interfacing. At the other end of the system, after the MCU’s DAC, these operations were inverted so our signal once again mimicked that of a standard guitar. Below, a schematic of our electrical system can be seen.\n Figure 2: Full surrounding electrical schematic for signal voltage adjustment"
  },
  {
    "objectID": "project/project_final_report/project_final_report.html#bill-of-materials",
    "href": "project/project_final_report/project_final_report.html#bill-of-materials",
    "title": "E155 Final Report: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "Below is a figure detailing the bill of materials used in this project.\n\n\n\nCategory\nProduct\nPart Number\nUnit Price\nQTY\nTotal+Tax\nDatasheet/Link\n\n\n\n\n\n\n\n\n\n\n\n\n\nDual Rail Op Amp\nOP07 Ultralow Offset VoltageOperational Amplifier\nOP07CPZ-ND\nStock Room\n2\n0\nhttps://www.analog.com/media/en/technical-documentation/data-sheets/op07.pdf\n\n\nSingle Rail Op Amp\nMCP601-I/P\nMCP601-I/P-ND\nStock Room\n0\n0\nhttps://ww1.microchip.com/downloads/en/DeviceDoc/21314g.pdf\n\n\nAudio Input Jack\nLOCHSOEL 6.35mm (1/4inch) Female Stereo Socket Panel Mount Jacks, Pack of 6\nACJM-MN-2\n1.55\n3\n4.65\nhttps://www.amphenol-sine.com/pdf/catalog/CAT-AUDIO.pdf\n\n\nADC Options\nMCP3202-CI/P\nMCP3202-CI/P-ND\n$1.66\n5\n$8.30\nhttps://ww1.microchip.com/downloads/aemDocuments/documents/APID/ProductDocuments/DataSheets/21034F.pdf\n\n\nToggle Switch\nCARLING TECHNOLOGIES Toggle Switch: 3 Position, 6 Connections, DPDT, G Series\n2GM51 - 73\n0\n4\n0\nhttps://www.grainger.com/ec/pdf/G-SeriesSW_Details_26_COS__EHSU_v1.pdf\n\n\nResistors\n100 K Ω Resistor\nNA\nStock Room\n0\n0\n\n\n\nPotentiometer\n100 K Ω Potentiometer\nNA\nStock Room\n0\n0\n\n\n\n\n\n\n\n\n\n\n\n\nTotal Cost\n12.95\n\n\n\n\n\n\n\n\nFigure 3: Bill of materials detailing materials aquired for use in this project"
  },
  {
    "objectID": "project/project_final_report/project_final_report.html#results",
    "href": "project/project_final_report/project_final_report.html#results",
    "title": "E155 Final Report: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "In our project, we were unable to achieve the goals we had set for our FPGA design. A major roadblock for us was interfacing the ADC with the FPGA. This error was very confusing with us, as communication over SPI was intermmittent and unstable, but did work occasionally. Too late in our project, we realized that the sampling rate that we wanted to achieve with our FPGA architecture was not compatible with the ADC we had purchased. As a result, we had to modify our clock tree and sampling rate previously designed.\nAnother major roadblock we navigated was loading the shift register for the MCU to read samples from the FPGA. This happened because the FPGA ran on its own clock domain, and the MCU ran its SPI transactions on a separate clock that ran approximately 500 MHz faster than that on the FPGA. However, this roadbock was successfully navigated and can be seen in the following section.\nThe MCU systems we aimed to implement worked well on their own. The first major piece of our design was the SPI communications between the MCU and the FPGA. By looking at the digital trace of these communications below, we can see that the MCU successfully retrieved a sample from the FPGA.\n Figure 4: FPGA to MCU SPI transaction\nThe next step was for the MCU to use the onboard DAC to process a clean signal and send it through our postprocessing chain. This was done in the image seen below using a sample frequency, indicating that we were capable of outputting a known voltage.\n Figure 5: Clean MCU output wave trace\nFinally, we implemented the distortion effect, which functions by clipping the edges of our signal range to make our audio waves more square. This gives the audio a distorted effect, which can be seen in songs as early as Voodoo Child (Slight Return) by Jimi Hendrix. Below is an oscilloscope trace conveying a working distortion signal using sample data.\n Figure 6: MCU output wave trace with distortion"
  },
  {
    "objectID": "project/project_final_report/project_final_report.html#reflection",
    "href": "project/project_final_report/project_final_report.html#reflection",
    "title": "E155 Final Report: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "Overall, our team learned a lot in the experience of completing the project, even if we did not achieve the final goal of creating a functional guitar pedal. We definitely undersold ourselves on the amount of time we would need to complete our project, and it ended up being the nail in the coffin for our group. However, we did learn valuable lessons in reading our datasheets and learning specific SPI protocols. We also gained valuable experience in designing clock domains with synchrony across multiple clocks, which was a difficult but valuable achievement for us in the later stages of our project.\nWe also think that the architecture for our project was very solid, and the various components for the project were ones we feel were right for the job. Given a few more days, we believe we could have bugfixed the commnunications between the ADC and FPGA, which would have processed a clean sample for us. Following this, we would have been able to complete modifications to the FPGA datapath that would have allowed averaging of past samples to enable reverb and chorus effects. Finally, enabling the RNG peripheral on the MCU would have given us a method for implementing the vibrato effect on the signal, completing our fourth and final effect, and the total goal for our project."
  },
  {
    "objectID": "project/project_final_report/project_final_report.html#acknowledgements",
    "href": "project/project_final_report/project_final_report.html#acknowledgements",
    "title": "E155 Final Report: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "We want to thank Prof. Spencer, Javier, and the E155 grutoring team for their guidance and advice as we went along the path of this project. We also want to thank engineering staff as a whole for their support, especially in the final push of the project and in aquiring the materials necessary to complete the project."
  },
  {
    "objectID": "project/project_final_report/project_final_report.html#references-and-code",
    "href": "project/project_final_report/project_final_report.html#references-and-code",
    "title": "E155 Final Report: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "STM32L432KC Documentation and Reference Manual\nICE40UP5K Family Datasheet\nMicrochip MCP3202 ADC Documentation\nGitHub Project Repository"
  },
  {
    "objectID": "project.html",
    "href": "project.html",
    "title": "Final Project",
    "section": "",
    "text": "E155 Final Report: Multi-Effect Guitar Pedal\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nE155 Final Project: Multi-Effect Guitar Pedal\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "project_midpoint.html",
    "href": "project_midpoint.html",
    "title": "Final Project Midpoint",
    "section": "",
    "text": "E155 Final Project: Midpoint Check-In\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  }
]
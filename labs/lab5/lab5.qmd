---
title: "Lab 5"
description: "Programming a STM32L432KC Microcontroller to read pulses from a motor encoder and interpreting those waves as interupts in order to calculate rotation speed."
author: "Kanoa Parker"
date: "10/7/2025"
---
# Table of Contents
1. [Introduction](#introduction)
2. [Schematic](#Schematic)
3. [Flow Chart](#flow_chart)
4. [C Code](#c_code)
        4.1 [main](#main)
        4.2 [EXTI0_IRQHandler](#exti0)
        4.3 [EXTI1_IRQHandler](#exti1)
        4.4 [interupt_setup](#int_setup)
5. [Calculation](#calc)
6. [Comparison of Manual vs Interupts](#compare)
7. [AI Prototype](#aip)

# This it the Introduction <a name="introdction"></a>
In this Lab I programmed a STM32L432KC Microcontroller to read the speed of a 25GA-370 DC Brusheless Motor. The microcontroller read the square wave produced by the motor's encoder and turned those signals into interupts. Both the rising and falling edge of the
pulse were counted as interupt signals. Using an interupt handler which determined whether the signal was a rising or falling edge the signal was recorded and the interupt flag reset. The lab meets all specificfication and took 8 hours total to complete.

# Schematic <a name="Schematic"></a>
![Schematic of Bread Board](images\schematiclab111.png)

# Flow Chart <a name="flow_chart"></a>
![Blcok Diagramof Verilog Code](images\blockdiagram-12.jpg)

# C Code <a name="c_code"></a>
This section contains code for the main module and interupt handlers and setup.

## main <a name="main"></a>

```C
int main(void) {
    pinMode(PA2,GPIO_OUTPUT);
    printf("Sequence Start\n");
    int volatile n = 0;

    // Set system clock to 80 MHz
    //configureClock();
    //configurePLL();
    //printf("Clock Configure\n");

    // Enable button as input
    gpioEnable(GPIO_PORT_A);
    printf("Gpio Enable\n");
    pinMode(PA0, GPIO_INPUT);
    pinMode(PA1, GPIO_INPUT);
    pinMode(PA2, GPIO_OUTPUT);
    printf("Pinmode\n");
    GPIOA->PUPDR |= _VAL2FLD(GPIO_PUPDR_PUPD0, 0b10); // Set PA0 as pull down
    GPIOA->PUPDR |= _VAL2FLD(GPIO_PUPDR_PUPD1, 0b10); // Set PA1 as pull down
    printf("Pull Up and Down\n");

    // Initialize timer
    RCC->APB1ENR1 |= RCC_APB1ENR1_TIM2EN;
    initTIM(DELAY_TIM);
    printf("Timer Initialize\n");

    //set up interupts
    interupt_set();
    printf("Interupt Set\n");
    
    int volatile leadA;
    printf("Volatile A Set\n");
    int volatile leadB;
    printf("Hit While Loop\n");
    int volatile nn=0;
    
    digitalWrite(PA2,PIO_HIGH);
    while(1){
        

        //interupt handler
        EXTI0_IRQHandler();
        EXTI1_IRQHandler();
        
        
        //calculate speed
        
        //write to serial if it has been a second
        if (write_counter==1000) {
            speed = (float)(A_count + B_count)/(816.0*2); 
            printf("Current Speed is %f REV/s\n", speed);
            write_counter = 0;
            printf("Acount %d Bcount %d \n", A_count, B_count);
            A_count = 0;
            B_count = 0;
            printf("%d \n", nn);
            nn = nn+1;
            
        }
        
        //delay and increment counter
        delay_millis(TIM2,1);
        write_counter = (write_counter + 1);
        //printf("%d \n", write_counter);
        togglePin(PA2);
        
        

    }
}
```
Main Module.  
Link to github with full list of library and header files. 
[Link to Git Hub](https://github.com/kanparker/e155_lab5).

## EXTI0_IRQHandler <a name="exti0"></a>

```c
void EXTI1_IRQHandler(void) {
    //read the leads
    int leadA = digitalRead(PA0);
    int leadB = digitalRead(PA1);
    // Check that the button was what triggered our interrupt
    if (EXTI->PR1 & (1 << gpioPinOffset(PA1))){
        // If so, clear the interrupt (NB: Write 1 to reset.)
        EXTI->PR1 |= (1 << gpioPinOffset(PA1));
        //Rising Edge
        if(leadB == 1){
            //check direction
            if(leadA ==1){
                B_count = B_count + 1;
            }
            else{
                B_count = B_count - 1;
            }
        }
        //Falling Edge
        else{
            if(leadA ==0){
                B_count = B_count + 1;
            }
            else{
                B_count = B_count - 1;
            }
        }
    }
}
```
Interupt handler for EXTI0 which is connected to the encoder signal A.

## EXTI1_IRQHandler <a name="exti1"></a>

```c
void EXTI0_IRQHandler(void) {
    // Check that the button was what triggered our interrupt
    int leadA = digitalRead(PA0);
    int leadB = digitalRead(PA1);
    if (EXTI->PR1 & (1 << gpioPinOffset(PA0))){
        // If so, clear the interrupt (NB: Write 1 to reset.)
        EXTI->PR1 |= (1 << gpioPinOffset(PA0));
        //Rising Edge
        if(leadA == 1){
            //check direction
            if(leadB ==0){
                A_count = A_count + 1;
            }
            else{
                A_count = A_count - 1;
            }
        }
        //Falling Edge
        else{
            if(leadB ==0){
                A_count = A_count - 1;
            }
            else{
                A_count = A_count + 1;
            }
        }
    }
}
```
Interupt handler for EXTI0 which is connected to the encoder signal A.

## interupt_setup<a name="int_setup"></a>
```c
int interupt_set(void) {
    // 1. Enable SYSCFG clock domain in RCC
    RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
    // 2. Configure EXTICR for the input button interrupt
    SYSCFG->EXTICR[1] |= _VAL2FLD(SYSCFG_EXTICR1_EXTI0, 0b000); // Select PA0
    SYSCFG->EXTICR[1] |= _VAL2FLD(SYSCFG_EXTICR1_EXTI1, 0b000); // Select PA1

    

    // Configure interrupt for falling and rising edge of GPIO pin for button
    // 1. Configure mask bit
    EXTI->IMR1 |= (1 << gpioPinOffset(PA0)); // Configure the mask bit
    EXTI->IMR1 |= (1 << gpioPinOffset(PA1)); // Configure the mask bit

    // 2. Enable rising edge trigger
    EXTI->RTSR1 |= (1 << gpioPinOffset(PA0));// Disable rising edge trigger
    EXTI->RTSR1 |= (1 << gpioPinOffset(PA1));// Disable rising edge trigger

    // 3. Enable falling edge trigger
    EXTI->FTSR1 |= (1 << gpioPinOffset(PA0));// Enable falling edge trigger
    EXTI->FTSR1 |= (1 << gpioPinOffset(PA1));// Enable falling edge trigger

    // 4. Turn on EXTI interrupt in NVIC_ISER
    NVIC->ISER[0] |= (1 << EXTI0_IRQn);
    NVIC->ISER[0] |= (1 << EXTI1_IRQn);
    
    // Enable interrupts globally
    __enable_irq();
    
}
```
Interupt setup and handle.

# Calculations <a name="calc"></a>

# Comparison of Manual vs Interupts <a name="compare"></a>

# AI Prototype <a name="aip"></a>

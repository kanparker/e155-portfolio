---
title: "Lab 1"
description: "Programming a Seven Segment display and 3 LEDs with Combinational Logic"
author: "Kanoa Parker"
date: "9/2/2025"
---
# Table of Contents
1. [Introduction](#introduction)
2. [Schematic](#Schematic)
3. [Block Diagram](#block_diagram)
4. [Verilog Code](#verilog_code)
        4.1 [top](#topmod)
        4.2 [seven_segment_display](#sevenseg)
        4.3 [three_led](#threeled)
5. [Test Benches](#test_benches)
    5.1 [testbench](#test_bench)
    5.2 [seven_testbench](#seven_tb)
    5.3 [three_testbench](#three_tb)

6. [Notes](#notes_extra)
7. [AI Prototype](#aipro)

# This it the Introduction <a name="introdction"></a>

In this lab I built my E155 develpement board with contains a UPduino v3.1 FPGA and a Nucleo-L432KC boards. Using Verilog HDL I programmed the FPGA to control a seven segmented display to show Hexadecimal 0x0 to 0xF. Before programming the board I simulated my hardware in Questa Simulations using a test bench. In addition the FPGA also controls 3 LEDS. The lab meets all specifications. This Lab took 7 hours.

# Schematic <a name="Schematic"></a>
![Schematic of Bread Board](images\lab1schematic.jpg)

# Block Diagram <a name="block_diagram"></a>
![Blcok Diagramof Verilog Code](images\lab1block.jpg)

# Verilog Code <a name="verilog_code"></a>
This section contains verilog code for modules top seven_segment_display and three_led

## top <a name="topmod"></a>

```Verilog
module top(
	input 	logic	[3:0]s,
	output 	logic [2:0]led,
	output logic [6:0]seg
);
	//top module for lab1
	three_led three(s, led);
	seven_seg_display seven(s,seg);
	
	

endmodule

```
Top level module. 

## seven_segment_display <a name="sevenseg"></a>

```verilog
module seven_seg_display(
	input 	logic	[3:0]s,
	output 	logic [6:0]seg
);
	//Seven segment display based on switch inputs, s[3:0] are input switches and seg[6:0] are for each segment of the display

	logic A,B,C,D;
	
	assign A = s[3];
	assign B = s[2];
	assign C = s[1];
	assign D = s[0];
	
	always_comb
		case(s[3:0])
			/// 0
			4'b0000: seg[6:0] = 7'b0000001;
			/// 1
			4'b0001: seg[6:0] = 7'b1001111;
			/// 2
			4'b0010: seg[6:0] = 7'b0010010;
			/// 3
			4'b0011:seg[6:0] = 7'b0000110;
			/// 4
			4'b0100:seg[6:0] = 7'b1001100;
			/// 5
			4'b0101:seg[6:0] = 7'b0100100;
			/// 6
			4'b0110:seg[6:0] = 7'b0100000;
			/// 7
			4'b0111:seg[6:0] = 7'b0001111;
			/// 8
			4'b1000:seg[6:0] = 7'b0000000;
			/// 9
			4'b1001:seg[6:0] = 7'b0001100;
			/// A
			4'b1010:seg[6:0] = 7'b0001000;
			/// B
			4'b1011:seg[6:0] = 7'b1100000;
			/// C
			4'b1100:seg[6:0] = 7'b0110001;
			/// D
			4'b1101:seg[6:0] = 7'b1000010;
			/// E
			4'b1110:seg[6:0] = 7'b0110000;
			/// F
			4'b1111:seg[6:0] = 7'b0111000;
		endcase
			
	

endmodule
```
Seven segment display takes an input of four switches, s[3:0], and ouputs to light up the seven segment display, seg[6:0]

## three_led    <a name="three_led"></a>
```verilog
module three_led(
	input 	logic	[3:0]s,
	output 	logic [2:0]led
);
	// Three led takes in an input of four switches, s[3:0], and turns on or off leds, led[2:0].

	logic int_osc;
	logic pulse;
	logic led_state = 0;
	logic [31:0] counter = 0;
	logic [31:0] P;
	
	assign P = 32'b00000000000000000000000011010111;
	
	// Internal high-speed oscillator
	HSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(int_osc));
	
	// Simple clock divider
	always_ff @(posedge int_osc)
		begin
			counter <= counter + P;
		end
	
	xor x1(led[0],s[1],s[0]);
	and a1(led[1],s[3],s[2]);
	
	assign led[2] = counter[31];
	

endmodule
```

Three led takes in an input of four switches, s[3:0], and turns on or off leds, led[2:0].

# Test Benches <a name="test_benches"></a>


## test_bench <a name="test_bench"></a>
![Full Test Bench Sim Results](images\fulltestbenchsim.jpg)
[Link to Test Bench File](https://github.com/kanparker/E155-lab1/blob/lab1branch/fpga/src/e155_lab1/source/impl_1/testbench.sv)

## seven_testbench <a name="seven_tb"></a>
![Full Test Bench Sim Results](images\sevensegsim.jpg)
[Link to Test Bench File](https://github.com/kanparker/E155-lab1/blob/lab1branch/fpga/src/e155_lab1/source/impl_1/testbench_seven.sv)

## three_testbench <a name="three_tb"></a>
![Full Test Bench Sim Results](images\threeled.jpg)
[Link to Test Bench File](https://github.com/kanparker/E155-lab1/blob/lab1branch/fpga/src/e155_lab1/source/impl_1/testbench_three.sv)

# Notes <a name="notes_extra"></a>
![LED calculations](images/lab1curentcalc.jpg)

# AI prototype <a name="aipro"></a>
Hereâ€™s a clean, modern SystemVerilog module that uses the internal high-speed oscillator (HSOSC) of the Lattice iCE40UP5K FPGA to blink an LED at 2 Hz, taking full advantage of SystemVerilogâ€™s strong typing (logic, always_ff, localparam, etc.).

âœ… SystemVerilog HDL (for Lattice UP5K)
```verilog
//==============================================================
// Blink LED at 2 Hz using the internal 48 MHz oscillator
// Target device: Lattice iCE40UP5K
//==============================================================

module led_blinker_2hz (
    output logic led
);

    //==========================================================
    // Internal oscillator instantiation (Lattice primitive)
    //==========================================================
    logic clk_hsosc;

    // The internal oscillator can run up to 48 MHz
    // Frequency trimming is not needed for simple timing like LED blinking
    HSOSC #(
        .CLKHF_DIV("0b00")  // "00" = 48 MHz, "01" = 24 MHz, "10" = 12 MHz, "11" = 6 MHz
    ) internal_osc (
        .CLKHFEN(1'b1),     // Enable output
        .CLKHFPU(1'b1),     // Power up
        .CLKHF(clk_hsosc)
    );

    //==========================================================
    // Clock divider logic
    //==========================================================
    //
    // To blink at 2 Hz (period = 0.5 s per toggle = 1 s full cycle),
    // with a 48 MHz clock:
    // 
    //   cycles_per_toggle = 48e6 / 2 = 24e6
    //
    // We'll toggle the LED every 24,000,000 cycles.

    localparam int unsigned CLK_FREQ_HZ = 48_000_000;
    localparam int unsigned BLINK_HZ    = 2;
    localparam int unsigned TOGGLE_COUNT = CLK_FREQ_HZ / (2 * BLINK_HZ); // 24,000,000

    logic [$clog2(TOGGLE_COUNT)-1:0] counter = '0;

    always_ff @(posedge clk_hsosc) begin
        if (counter == TOGGLE_COUNT - 1) begin
            counter <= '0;
            led <= ~led;  // Toggle LED
        end else begin
            counter <= counter + 1;
        end
    end

endmodule
```
ðŸ§  Explanation

HSOSC primitive:
The HSOSC block is a Lattice-specific primitive that provides a high-speed internal clock (up to 48 MHz).
Setting .CLKHF_DIV("0b00") uses the full 48 MHz.

Clock divider:
To blink at 2 Hz, the LED toggles every 0.25 seconds (since one toggle = half the period).
With 48 MHz input â†’ 48e6 / 4 = 12e6 toggles per second per full cycle â†’ 48e6 / (2 * 2) = 12e6.

Modern SystemVerilog constructs used:

logic instead of reg/wire

always_ff for sequential logic

localparam for constants

$clog2() for counter width inference

Clean numeric literals with underscores for readability

âš™ï¸ Synthesis Notes

Works in Lattice Radiant, Diamond, and IceStorm (nextpnr-ice40).

Ensure HSOSC is available in your device library (it is for the UP5K).

When targeting the UP5K on an iCEstick or iCEBreaker, connect the output led to the correct LED pin in your .pcf constraints file.

Would you like me to include a matching .pcf (pin constraint) example for the iCEBreaker board or another specific UP5K board?

## Reflection
The code synthesized well and completed with no errors. The quality overall is pretty decent work however it uses a lot more advance features than what we 
have covered in class so far. It uses a lot of localparam in unsigned vs just having what I did which was logic and it uses integers vs what I used which was all binary
which seems that he LLM made it more readable. Overall it is pretty straight forward just syntaxing is a little unfamilar.

How would you rate the quality of the output and why?
What SystemVerilog constructs/syntax did the LLM generated that were new to you?
Did the LLM-generated code synthesize the first time around? If not, what were the issues?
What error or warning messages did Radiant output?
What would you do differently the next time you use an LLM in your workflow?
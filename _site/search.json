[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Resources",
    "section": "",
    "text": "Link to E155 Resources"
  },
  {
    "objectID": "labss.html",
    "href": "labss.html",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab 1\n\n\nProgramming a Seven Segment display and 3 LEDs with Combinational Logic\n\n\n\n\n\nSep 2, 2025\n\n\nKanoa Parker\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2\n\n\nProgramming a Dual Seven Segment display controlled by 2 sets of 4 dipswitches. Using a time multiplexer the inputs from four switches control one half of the display. In addition 5 leds indicate the sum of the two sets of 4 dip switches.\n\n\n\n\n\nSep 9, 2025\n\n\nKanoa Parker\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3\n\n\nLab 3\n\n\n\n\n\nAug 29, 205\n\n\nKanoa Parker\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4\n\n\nProgramming a STM32L432KC Microcontroller to output a PWM wave at specific freqeuncies and at specific durations in order to drive a speaker.\n\n\n\n\n\nSep 30, 2025\n\n\nKanoa Parker\n\n\n\n\n\n\n\n\n\n\n\n\nLab 5\n\n\nProgramming a STM32L432KC Microcontroller to read pulses from a motor encoder and interpreting those waves as interupts in order to calculate rotation speed.\n\n\n\n\n\nOct 7, 2025\n\n\nKanoa Parker\n\n\n\n\n\n\n\n\n\n\n\n\nLab 6\n\n\nProgramming a STM32L432KC Microcontroller to read temperature from a DS1722 and Display readings on a ESP8266 Webserver.\n\n\n\n\n\nNov 4, 205\n\n\nKanoa Parker\n\n\n\n\n\n\n\n\n\n\n\n\nLab 7\n\n\nLab 7\n\n\n\n\n\nAug 29, 205\n\n\nKanoa Parker\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6",
    "section": "",
    "text": "Introduction\nSchematic\nC Code 3.1 Main C 3.2 Main Header 3.3 Start Up Code 3.4 Update Sensitivity 3.5 Update LED 3.6 In String 3.7 Webserver set up 3.8 SPI Header 3.9 SPI C 3.10 DS1722 Header 3.11 DS1722 C\nSample Spi Communication\nAI Prototype"
  },
  {
    "objectID": "labs/lab6/lab6.html#main-c",
    "href": "labs/lab6/lab6.html#main-c",
    "title": "Lab 6",
    "section": "Main C ",
    "text": "Main C \nint main(void) {\n    /*\n    File: main.c\n    Author: kanoa Parker\n    Email: kanoa.parker@hmc.edu\n    Date: 11/4/2025\n    Description: Code for STM32L432KC to read temperature data from DS1722 and display temperature on Webpage\n    */\n  startup();\n\n  USART_TypeDef * USART = initUSART(USART1_ID, 125000);\n  \n  volatile uint8_t sensitivity;\n  volatile float temperature;\n  volatile char tempstring[50];\n  volatile int led_status;\n  char ledStatusStr[20];\n  char sensitivitystatus[20];\n  set_sensitivity(0xe0);\n  \n  while(1) {\n    /* Wait for ESP8266 to send a request.\n    Requests take the form of '/REQ:&lt;tag&gt;\\n', with TAG begin &lt;= 10 characters.\n    Therefore the request[] array must be able to contain 18 characters.\n    */\n    \n    // Receive web request from the ESP\n    char request[BUFF_LEN] = \"                  \"; // initialize to known value\n    int charIndex = 0;\n  \n    // Keep going until you get end of line character\n    while(inString(request, \"\\n\") == -1) {\n      // Wait for a complete request to be transmitted before processing\n      while(!(USART-&gt;ISR & USART_ISR_RXNE));\n      request[charIndex++] = readChar(USART);\n    }\n    \n    //read temp\n    temperature = retrieve_temp();\n    //turns float to string\n    sprintf(tempstring, \"%f\",temperature);\n\n    // Update string with current LED state\n    led_status = updateLEDStatus(request, led_status);\n\n    \n    if (led_status == 1)\n      sprintf(ledStatusStr,\"LED is on!\");\n    else if (led_status == 0)\n      sprintf(ledStatusStr,\"LED is off!\");\n    \n    sensitivity = updateSensitivity(request, sensitivity);\n    set_sensitivity(sensitivity);\n\n    if(sensitivity == 0xe0)\n      sprintf(sensitivitystatus,\"8 bits\");\n    else if(sensitivity == 0xe2)\n      sprintf(sensitivitystatus,\"9 bits\");\n    else if(sensitivity == 0xe4)\n      sprintf(sensitivitystatus,\"10 bits\");\n    else if(sensitivity == 0xe6)\n      sprintf(sensitivitystatus,\"11 bits\");\n    else if(sensitivity == 0xe8)\n      sprintf(sensitivitystatus,\"12 bits\");\n\n    // finally, transmit the webpage over UART\n    sendString(USART, webpageStart); // webpage header code\n    sendString(USART, ledStr); // button for controlling LED\n\n    sendString(USART, \"&lt;h2&gt;LED Status&lt;/h2&gt;\");\n\n\n    sendString(USART, \"&lt;p&gt;\");\n    sendString(USART, ledStatusStr);\n    sendString(USART, \"&lt;/p&gt;\");\n    \n    sendString(USART,tempStr);\n    sendString(USART, \"&lt;p&gt;\");\n    sendString(USART, tempstring);\n    sendString(USART, \"Celsius &lt;/p&gt;\");\n    \n    sendString(USART, tempsensitivity);\n    sendString(USART, \"&lt;p&gt; Current sensitivity:\");\n    sendString(USART, sensitivitystatus);\n    sendString(USART, \"&lt;/p&gt;\");\n    sendString(USART, webpageEnd);\n    \n  }\nMain Module.\nLink to github with full list of library and header files. Link to Git Hub."
  },
  {
    "objectID": "labs/lab6/lab6.html#main-header",
    "href": "labs/lab6/lab6.html#main-header",
    "title": "Lab 6",
    "section": "Main Header ",
    "text": "Main Header \n/**\n    Main Header: Contains general defines and selected portions of CMSIS files\n    @file main.h\n    @author Kanoa parker\n    @email kanparker@hmc.edu\n    @date 11/4/2025\n*/\n\n#ifndef MAIN_H\n#define MAIN_H\n\n#include \"C:\\Users\\kanoa\\Documents\\hmc-e155\\lab\\lab06\\lib\\STM32L432KC.h\"\n\n#define LED_PIN PA8 // LED pin for blinking on Port B pin 3\n#define LED_PIN2 PA9\n#define BUFF_LEN 32\n\n#endif // MAIN_H"
  },
  {
    "objectID": "labs/lab6/lab6.html#startup",
    "href": "labs/lab6/lab6.html#startup",
    "title": "Lab 6",
    "section": "startup() ",
    "text": "startup() \nvoid startup(void){\n    ///startup code doing configurations\n  configureFlash();\n  configureClock();\n  gpioEnable(GPIO_PORT_A);\n  gpioEnable(GPIO_PORT_B);\n  gpioEnable(GPIO_PORT_C);\n  pinMode(LED_PIN, GPIO_OUTPUT);\n  RCC-&gt;APB2ENR |= (RCC_APB2ENR_TIM15EN);\n  initTIM(TIM15);\n  initSPI(0b101, 1, 1); // SPI clk = master clk / 64, CPOL = 1, CPHA = 1\n}\nInterupt handler for EXTI0 which is connected to the encoder signal A."
  },
  {
    "objectID": "labs/lab6/lab6.html#updatesensitivity",
    "href": "labs/lab6/lab6.html#updatesensitivity",
    "title": "Lab 6",
    "section": "updateSensitivity ",
    "text": "updateSensitivity \nuint8_t updateSensitivity(char request[],uint8_t current_sen)\n{       ///update sensitivity bits to be sent to DS1722 based on request from webserver\n        uint8_t sensitivity_status = current_sen;\n        if (inString(request, \"8b\")==1){\n          sensitivity_status= 0xe0;\n          //blinky();\n        }\n        else if (inString(request, \"9b\")==1){\n          sensitivity_status = 0xe2;\n          //blinky();\n        }\n        else if (inString(request, \"10b\")==1){\n          sensitivity_status = 0xe4;\n          //blinky();\n        }\n        else if (inString(request, \"11b\")==1){\n          sensitivity_status = 0xe6;\n          //blinky();\n        }\n        else if (inString(request, \"12b\")==1){\n          sensitivity_status = 0xe8;\n          //blinky();\n        }\n\n        return sensitivity_status;\n\n\n}\nInterupt handler for EXTI0 which is connected to the encoder signal A."
  },
  {
    "objectID": "labs/lab6/lab6.html#updateledstatus",
    "href": "labs/lab6/lab6.html#updateledstatus",
    "title": "Lab 6",
    "section": "updateLEDStatus",
    "text": "updateLEDStatus\nint updateLEDStatus(char request[], int current_status)\n{   ///updates led status based on webserver request\n    int led_status = current_status;\n    // The request has been received. now process to determine whether to turn the LED on or off\n    if (inString(request, \"ledoff\")==1) {\n        digitalWrite(LED_PIN, GPIO_LOW);\n        led_status = 0;\n    }\n    else if (inString(request, \"ledon\")==1) {\n        digitalWrite(LED_PIN, GPIO_HIGH);\n        led_status = 1;\n    }\n\n    return led_status;\n}"
  },
  {
    "objectID": "labs/lab6/lab6.html#instring",
    "href": "labs/lab6/lab6.html#instring",
    "title": "Lab 6",
    "section": "inString",
    "text": "inString\nint inString(char request[], char des[]) {\n    ///checks for if char is in request\n    if (strstr(request, des) != NULL) {return 1;}\n    return -1;\n}"
  },
  {
    "objectID": "labs/lab6/lab6.html#html-webpage-setup",
    "href": "labs/lab6/lab6.html#html-webpage-setup",
    "title": "Lab 6",
    "section": "HTML Webpage Setup ",
    "text": "HTML Webpage Setup \n//Defining the web page in two chunks: everything before the current time, and everything after the current time\nchar* webpageStart = \"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;E155 Web Server Demo Webpage&lt;/title&gt;\\\n    &lt;meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"&gt;\\\n    &lt;/head&gt;\\\n    &lt;body&gt;&lt;h1&gt;E155 Web Server Demo Webpage&lt;/h1&gt;\";\nchar* ledStr = \"&lt;p&gt;LED Control:&lt;/p&gt;&lt;form action=\\\"ledon\\\"&gt;&lt;input type=\\\"submit\\\" value=\\\"Turn the LED on!\\\"&gt;&lt;/form&gt;\\\n    &lt;form action=\\\"ledoff\\\"&gt;&lt;input type=\\\"submit\\\" value=\\\"Turn the LED off!\\\"&gt;&lt;/form&gt;\";\n//Defining Temperature Reading\nchar* tempStr = \"&lt;h2&gt; Temperature Sensor Reading:&lt;/h2&gt;\";\n//Form for temperature sensitivity\nchar* tempsensitivity = \"&lt;p&gt;Temperature Sensitivity Control&lt;/p&gt;&lt;form action= \\\"sensitivity\\\"&gt;\\\n  &lt;input type=\\\"radio\\\" id=\\\"8 bit\\\" name=\\\"fav\\\" value=\\\"8b\\\"&gt;\\\n  &lt;label for=\\\"8 bit\\\"&gt;8 bit&lt;/label&gt;&lt;br&gt;\\\n  &lt;input type=\\\"radio\\\" id=\\\"9 bit\\\" name=\\\"fav\\\" value=\\\"9b\\\"&gt;\\\n  &lt;label for=\\\"9 bit\\\"&gt;9 bit&lt;/label&gt;&lt;br&gt;\\\n  &lt;input type=\\\"radio\\\" id=\\\"10 bit\\\" name=\\\"fav\\\" value=\\\"10b\\\"&gt;\\\n  &lt;label for=\\\"10 bit\\\"&gt;10 bit&lt;/label&gt;&lt;br&gt;\\\n  &lt;input type=\\\"radio\\\" id=\\\"11 bit\\\" name=\\\"fav\\\" value=\\\"11b\\\"&gt;\\\n  &lt;label for=\\\"11 bit\\\"&gt;11 bit&lt;/label&gt;&lt;br&gt;\\\n  &lt;input type=\\\"radio\\\" id=\\\"12 bit\\\" name=\\\"fav\\\" value=\\\"12b\\\"&gt;\\\n  &lt;label for=\\\"12 bit\\\"&gt;12 bit&lt;/label&gt;&lt;br&gt;\\\n  &lt;input type=\\\"submit\\\" value=\\\"Submit\\\"&gt;\\\n  &lt;/form&gt;\";\nchar* webpageEnd   = \"&lt;/body&gt;&lt;/html&gt;\";"
  },
  {
    "objectID": "labs/lab6/lab6.html#spi-header",
    "href": "labs/lab6/lab6.html#spi-header",
    "title": "Lab 6",
    "section": "SPI Header ",
    "text": "SPI Header \n// STM32L432KC_SPI.h\n// TODO: Kanoa Parker\n//kanparker@hmc.edu\n// 11/4/2025\n//SPI header file\n\n#ifndef STM32L4_SPI_H\n#define STM32L4_SPI_H\n\n#include &lt;stdint.h&gt;\n#include &lt;stm32l432xx.h&gt;\n\n///////////////////////////////////////////////////////////////////////////////\n// Function prototypes\n///////////////////////////////////////////////////////////////////////////////\n\n/* Enables the SPI peripheral and intializes its clock speed (baud rate), polarity, and phase.\n *    -- br: (0b000 - 0b111). The SPI clk will be the master clock / 2^(BR+1).\n *    -- cpol: clock polarity (0: inactive state is logical 0, 1: inactive state is logical 1).\n *    -- cpha: clock phase (0: data captured on leading edge of clk and changed on next edge, \n *          1: data changed on leading edge of clk and captured on next edge)\n * Refer to the datasheet for more low-level details. */ \nvoid initSPI(int br, int cpol, int cpha);\n\n/* Transmits a character (1 byte) over SPI and returns the received character.\n *    -- send: the character to send over SPI\n *    -- return: the character received over SPI */\nchar spiSendReceive(char send);\n    \n#endif"
  },
  {
    "objectID": "labs/lab6/lab6.html#spi-c-file",
    "href": "labs/lab6/lab6.html#spi-c-file",
    "title": "Lab 6",
    "section": "SPI C File ",
    "text": "SPI C File \n// STM32L432KC_SPI.c\n// TODO: Kanoa Parker\n// TODO: kanparker@hmc.edu\n// TODO: 11/4/2025\n// TODO: SPI C files to send and recieve data\n\n#include \"STM32L432KC.h\"\n#include \"STM32L432KC_SPI.h\"\n#include \"STM32L432KC_RCC.h\"\n#include \"STM32L432KC_GPIO.h\"\n\nvoid initSPI(int br, int cpol, int cpha){\n    // Enable SPI1 clock\n    RCC-&gt;APB2ENR |= RCC_APB2ENR_SPI1EN;\n    RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOAEN;\n    RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOBEN; // Enable GPIOA clock for SPI1 pins\n    \n    // Configure GPIO pins for SPI1\n    pinMode(PB3, GPIO_ALT); // SCK\n    pinMode(PB4, GPIO_ALT); // MISO\n    pinMode(PB5, GPIO_ALT); // MOSI\n    pinMode(PB1, GPIO_OUTPUT); // CE\n\n    //Set alternate function to AF5 (SPI1)\n    GPIOB-&gt;AFR[0] |= _VAL2FLD(GPIO_AFRL_AFSEL3, 5);\n    GPIOB-&gt;AFR[0] |= _VAL2FLD(GPIO_AFRL_AFSEL4, 5);\n    GPIOB-&gt;AFR[0] |= _VAL2FLD(GPIO_AFRL_AFSEL5, 5);\n    \n    GPIOB -&gt;OSPEEDR |= (GPIO_OSPEEDR_OSPEED3); // Set PA5 speed to high\n    // Configure SPI1\n    SPI1-&gt;CR1 = 0; // Reset CR1 register\n    \n    // Set baud rate, clock polarity, and clock phase\n    SPI1-&gt;CR1 &= ~(SPI_CR1_CPOL | SPI_CR1_CPHA | SPI_CR1_LSBFIRST | SPI_CR1_SSM);\n    SPI1-&gt;CR1 |= _VAL2FLD(SPI_CR1_BR, br);\n    SPI1-&gt;CR1 |= _VAL2FLD(SPI_CR1_CPOL, cpol);\n    SPI1-&gt;CR1 |= _VAL2FLD(SPI_CR1_CPHA, cpha);\n\n    // Set as Master,\n    SPI1-&gt;CR1 |= _VAL2FLD(SPI_CR1_MSTR,1); \n\n    // Set data frame format to 8 bits\n    SPI1-&gt;CR2 |= _VAL2FLD(SPI_CR2_DS,0b0111);\n\n    SPI1-&gt;CR2 |= (SPI_CR2_FRXTH); // Set RXNE threshold to 8 bits\n    SPI1-&gt;CR2 |= (SPI_CR2_SSOE); // Enable SS output\n\n    // Enable SPI\n    SPI1-&gt;CR1 |= SPI_CR1_SPE;\n\n\n}\n\nchar spiSendReceive(char send){\n    // Wait until TXE (Transmit buffer empty) flag is set\n    while(!(SPI1-&gt;SR & SPI_SR_TXE));\n    // Send data\n    *(volatile uint8_t *) (&SPI1-&gt;DR) = send;\n    \n    // Wait until RXNE (Receive buffer not empty) flag is set\n    while(!(SPI1-&gt;SR & SPI_SR_RXNE));\n    // Read and return received data\n    char readval = (volatile char) SPI1-&gt;DR;\n    return readval;\n}"
  },
  {
    "objectID": "labs/lab6/lab6.html#ds1722-header",
    "href": "labs/lab6/lab6.html#ds1722-header",
    "title": "Lab 6",
    "section": "DS1722 Header ",
    "text": "DS1722 Header \n// DS1722.h\n// TODO: Kanoa Parker\n// TODO: kanparker@g.hmc.edu\n// TODO: 11/3/2025\n// TODO: Modules for setting temperature sensitivity and extracting temperature data from DS1722\n\n#ifndef STM32L4_DS1722_H\n#define STM32L4_DS1722_H\n\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stm32l432xx.h&gt;\n#include \"STM32L432KC_GPIO.h\"\n\n\n\nfloat retrieve_temp(void);\n\nvoid set_sensitivity(uint8_t sensitivity);\n#endif"
  },
  {
    "objectID": "labs/lab6/lab6.html#ds1722-c",
    "href": "labs/lab6/lab6.html#ds1722-c",
    "title": "Lab 6",
    "section": "DS1722 C ",
    "text": "DS1722 C \n// DS1722.c\n// TODO: Kanoa Parker\n// TODO: kanparker@g.hmc.edu\n// TODO: 11/3/2025\n// TODO: Modules for setting temperature sensitivity and extracting temperature data from DS1722\n\n#include \"STM32L432KC_GPIO.h\"\n#include \"STM32L432KC_SPI.h\"\n#include \"DS1722.h\"\n\n\nfloat retrieve_temp(void){\n    volatile uint16_t temp_reading;\n    volatile uint8_t temp_reading2;\n    volatile uint8_t sensitivity;\n    volatile float temperature;\n    //volatile char tempstring[50];\n\n    digitalWrite(PB1,GPIO_HIGH);\n    spiSendReceive(0x02); //First half of bits address\n    temp_reading = spiSendReceive(0x50);\n    digitalWrite(PB1,GPIO_LOW);\n    //printf(\"First Half of Bits is %d\\n\",temp_reading);\n    \n    digitalWrite(PB1,GPIO_HIGH);\n    spiSendReceive(0x01);\n    temp_reading2 = spiSendReceive(0x50); //Second half of bits\n    digitalWrite(PB1,GPIO_LOW);\n    //printf(\"Second half of bits %d\\n\",temp_reading2);\n    \n    temp_reading = ((uint16_t)(temp_reading)&lt;&lt;8 | temp_reading2);\n    temp_reading = (float)(temp_reading);\n    temperature = temp_reading/256.0;\n    //printf(\"The temperature is: %f\\n\",temperature);\n    //sprintf(tempstring, \"%f\",temperature);\n    return temperature;\n}\n\nvoid set_sensitivity(uint8_t sensitivity){\n    digitalWrite(PB1,GPIO_HIGH);\n    spiSendReceive(0x80);  \n    spiSendReceive(sensitivity);\n    digitalWrite(PB1,GPIO_LOW);\n}"
  },
  {
    "objectID": "labs/lab6/lab6.html#respone-from-chatgpt-html-code-and-rendered-code",
    "href": "labs/lab6/lab6.html#respone-from-chatgpt-html-code-and-rendered-code",
    "title": "Lab 6",
    "section": "Respone from Chatgpt HTML Code and rendered code",
    "text": "Respone from Chatgpt HTML Code and rendered code\n\n\n\nRendered Website\n\n\nDone ‚Äî I created a single-file HTML page titled temperature-portal.html in the canvas (you can open it on the right).\nWhat‚Äôs included\nClean, responsive UI with modern dark theme and accessible controls.\nBig live temperature readout (with unit) and a small sparkline showing recent history.\nPrecision selector (0‚Äì3 decimals).\nLED control with animated indicator and buttons (sends via WebSocket if connected, falls back to POST /api/led).\nWebSocket connection input (editable) and Connect / Disconnect buttons.\nDemo mode to simulate sensor data if you don‚Äôt have a backend.\nBasic logs panel and keyboard shortcut (Space toggles demo).\nHow to hook it up\nEdit the WebSocket URL in the ‚ÄúConnection‚Äù field (default ws://localhost:8080) and click Apply URL then Connect. WebSocket messages should be JSON like:\n{ ‚ÄúsensorId‚Äù: ‚Äúyour-id‚Äù, ‚Äútemp‚Äù: 23.12, ‚Äúunit‚Äù: ‚Äú¬∞C‚Äù }\nIf you prefer HTTP polling, implement GET /api/temperature that returns { ‚Äútemp‚Äù: 23.12, ‚Äúunit‚Äù: ‚Äú¬∞C‚Äù }. The page polls that endpoint every ~1.5s when not using WebSocket.\nLED: WebSocket will receive { ‚Äúled‚Äù: true } when user toggles; otherwise the page attempts POST /api/led with {‚Äúled‚Äù: true}.\nIf you want, I can:\nConvert this into a React component/page (single-file) with Tailwind.\nAdd authentication headers or an API-key flow.\nWire up MQTT instead of WebSocket, or adapt payload formats.\nTell me which of those (or anything else) you want next and I‚Äôll update the file directly."
  },
  {
    "objectID": "labs/lab6/lab6.html#temperature-c-code",
    "href": "labs/lab6/lab6.html#temperature-c-code",
    "title": "Lab 6",
    "section": "Temperature C Code",
    "text": "Temperature C Code\nHere‚Äôs a clean and robust example of a C function that uses CMSIS (and STM32 HAL-style register access) to perform a SPI transaction and retrieve the temperature reading from a DS1722 digital thermometer on an STM32L432KC.\n\n\nüß† Background\n\nThe DS1722 uses an SPI interface (Mode 3: CPOL=1, CPHA=1).\nTo read temperature, you issue a Read Temperature MSB command (0x02) and optionally the Read LSB command (0x01) after it, depending on resolution.\nEach register read is one byte, MSB first.\nThe temperature register is 16-bit, left-justified.\n\n\n\n\n‚úÖ Example Function\n#include \"stm32l4xx.h\"  // CMSIS header for STM32L4 series\n#include &lt;stdint.h&gt;\n\n// DS1722 Register addresses\n#define DS1722_REG_TEMP_MSB  0x02\n#define DS1722_REG_TEMP_LSB  0x01\n\n// SPI chip select macros\n#define DS1722_CS_LOW()   (GPIOA-&gt;BSRR = (uint32_t)(1 &lt;&lt; (4 + 16)))  // e.g., PA4 low\n#define DS1722_CS_HIGH()  (GPIOA-&gt;BSRR = (uint32_t)(1 &lt;&lt; 4))         // PA4 high\n\n// === Function: SPI Transfer (single byte) ===\nstatic uint8_t SPI_TransferByte(SPI_TypeDef *SPIx, uint8_t data)\n{\n    while (!(SPIx-&gt;SR & SPI_SR_TXE));     // Wait until TX buffer empty\n    *((__IO uint8_t *)&SPIx-&gt;DR) = data;  // Write data to SPI data register\n    while (!(SPIx-&gt;SR & SPI_SR_RXNE));    // Wait until RX buffer not empty\n    return *((__IO uint8_t *)&SPIx-&gt;DR);  // Read received data\n}\n\n// === Function: Read Temperature ===\nfloat DS1722_ReadTemperature(SPI_TypeDef *SPIx)\n{\n    uint8_t msb, lsb;\n    uint16_t raw;\n    float temperature;\n\n    DS1722_CS_LOW();\n\n    // Read MSB\n    SPI_TransferByte(SPIx, DS1722_REG_TEMP_MSB);  // Send command\n    msb = SPI_TransferByte(SPIx, 0x00);           // Dummy write to read\n\n    // Read LSB (optional for higher resolution)\n    SPI_TransferByte(SPIx, DS1722_REG_TEMP_LSB);\n    lsb = SPI_TransferByte(SPIx, 0x00);\n\n    DS1722_CS_HIGH();\n\n    // Combine bytes (MSB: bits 15‚Äì8, LSB: bits 7‚Äì0)\n    raw = ((uint16_t)msb &lt;&lt; 8) | lsb;\n\n    // Convert to ¬∞C\n    // DS1722 uses 0.5¬∞C per bit in 9-bit mode, or 0.0625¬∞C/bit in 12-bit mode.\n    // Assume 12-bit mode by default.\n    temperature = (raw &gt;&gt; 4) * 0.0625f;\n\n    return temperature;\n}\n\n\n\n‚öôÔ∏è Setup Notes\n\nSPI Configuration\n// Example: SPI1 on STM32L432KC\nRCC-&gt;APB2ENR |= RCC_APB2ENR_SPI1EN;\nRCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOAEN;\n\n// SPI1 pins: PA5=SCK, PA6=MISO, PA7=MOSI, PA4=CS\nGPIOA-&gt;MODER &= ~(GPIO_MODER_MODE4_Msk | GPIO_MODER_MODE5_Msk |\n                  GPIO_MODER_MODE6_Msk | GPIO_MODER_MODE7_Msk);\nGPIOA-&gt;MODER |= (1U &lt;&lt; GPIO_MODER_MODE5_Pos) | (1U &lt;&lt; GPIO_MODER_MODE6_Pos) | (1U &lt;&lt; GPIO_MODER_MODE7_Pos); // AF mode\nGPIOA-&gt;AFR[0] |= (5 &lt;&lt; (5*4)) | (5 &lt;&lt; (6*4)) | (5 &lt;&lt; (7*4)); // AF5 for SPI1\nGPIOA-&gt;MODER |= (1U &lt;&lt; GPIO_MODER_MODE4_Pos); // CS as output\nDS1722_CS_HIGH();\n\nSPI1-&gt;CR1 = SPI_CR1_MSTR | SPI_CR1_SSM | SPI_CR1_SSI |\n            SPI_CR1_CPOL | SPI_CR1_CPHA | SPI_CR1_BR_1; // Mode 3, Master, SSM\nSPI1-&gt;CR1 |= SPI_CR1_SPE; // Enable SPI\nCall Example\nfloat temp = DS1722_ReadTemperature(SPI1);\nprintf(\"Temperature: %.2f ¬∞C\\\\n\", temp);\n\n\n\n\nüß© Optional Enhancements\n\nAdd error checking (e.g., SPI timeout).\nHandle precision configuration (DS1722 allows setting resolution in config register 0x0A).\nWrap SPI init and read in FreeRTOS-safe critical sections if multitasking.\n\n\nWould you like me to extend this so it initializes the DS1722 (sets continuous conversion and precision) before reading temperature? That would make it fully ready for embedded use."
  },
  {
    "objectID": "labs/lab6/lab6.html#reflection",
    "href": "labs/lab6/lab6.html#reflection",
    "title": "Lab 6",
    "section": "Reflection",
    "text": "Reflection\nFor the website presonally I think it is really clean. The colors are a good contrast between the blue and the whie and the Temperature reading is nice and big so it is easy to see for the user. They have for the led on and off they have a rendered led which is visually very helpful. The precision is converted from bits to decimal which is more understandable for users. It has a bunch of other little features like last time update and a debug log at the bottom making it easier to fix. However when I tried to render it on my ESP8266 through the MCU the site would not render because I couldn‚Äôt even build it. The direct copy and paste was not viable because the formatting into char was a little different from what chat gave me.\nFor the C code provided by Chat GPT it was overall pretty good. However it doesn‚Äôt utilize a lot of preexisting libraries that I have. For example doing all the GPIO pin enables it is doing direct bit manipulation making it a little difficult to understand. IT forgets to do a few specific things such as seting RXNE threshold to 8 bits and enabling SS output. It doesn‚Äôt set hte frame format to 8 bits. For the temperature reading its overal really solid. It doesn‚Äôt declare any of the variables as volatile which is annoying. The way it converts from binay to float is also a little concerning. It does it differntly by then shifting the combined number back which does make sense but it assumes 12 bit resolution. The code doesn‚Äôt compile because there is some sort of syntax error involving a paranthesis."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4",
    "section": "",
    "text": "Introduction\nSchematic\nMCU Code 4.1 main 4.2 RCC Header 4.3 RCC C File 4.4 TIM 15 and TIM 16 Header 4.5 TIM 15 and TIM 16 C File 4.6 Flash Header 4.7 Flash C File 4.8 GPIO Header 4.9 GPIO C File\nCalculations 5.1 Max Min Delay 5.2 Max Min Frequency 5.2 Error\nNotes\n\n7.AI Prototype"
  },
  {
    "objectID": "labs/lab4/lab4.html#main",
    "href": "labs/lab4/lab4.html#main",
    "title": "Lab 4",
    "section": "main ",
    "text": "main \n/*********************************************************************\n*                    SEGGER Microcontroller GmbH                     *\n*                        The Embedded Experts                        *\n**********************************************************************\n\n-------------------------- END-OF-HEADER -----------------------------\n\nFile    : main.c\nPurpose : Main Header File to Play Song on 8 Ohm speaker\nAuthor: Kanoa Pakrer\nEmail: kanparker@g.hmc.edu\n*/\n\n#include &lt;stdio.h&gt;\n\n/*********************************************************************\n*\n*       main()\n*\n*  Function description\n*   Application entry point.\n*/\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_RCC.h\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_RCC.c\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_TIM_15_16.h\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_TIM_15_16.c\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_GPIO.h\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_GPIO.c\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_FLASH.h\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_FLASH.c\"\n\nconst int notes[][2] = {\n{659,   125},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{494,   125},\n{587,   125},\n{523,   125},\n{440,   250},\n{  0,   125},\n{262,   125},\n{330,   125},\n{440,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{416,   125},\n{494,   125},\n{523,   250},\n{  0,   125},\n{330,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{494,   125},\n{587,   125},\n{523,   125},\n{440,   250},\n{  0,   125},\n{262,   125},\n{330,   125},\n{440,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{523,   125},\n{494,   125},\n{440,   250},\n{  0,   125},\n{494,   125},\n{523,   125},\n{587,   125},\n{659,   375},\n{392,   125},\n{699,   125},\n{659,   125},\n{587,   375},\n{349,   125},\n{659,   125},\n{587,   125},\n{523,   375},\n{330,   125},\n{587,   125},\n{523,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{659,   125},\n{  0,   250},\n{659,   125},\n{1319,  125},\n{  0,   250},\n{623,   125},\n{659,   125},\n{  0,   250},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{494,   125},\n{587,   125},\n{523,   125},\n{440,   250},\n{  0,   125},\n{262,   125},\n{330,   125},\n{440,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{416,   125},\n{494,   125},\n{523,   250},\n{  0,   125},\n{330,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{494,   125},\n{587,   125},\n{523,   125},\n{440,   250},\n{  0,   125},\n{262,   125},\n{330,   125},\n{440,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{523,   125},\n{494,   125},\n{440,   500},\n{  0,   0}};\n\nint main(void) {\n  configureFlash();\n  configureClock();\n  RCC-&gt;AHB2ENR |=(1&lt;&lt;0);\n  RCC-&gt;APB2ENR |= (1 &lt;&lt; 16);\n  RCC-&gt;APB2ENR |= (1 &lt;&lt; 17); // Enable TIM15 and TIM16 clocks\n  RCC-&gt;CFGR &= ~(1 &lt;&lt; 13); // Set APB2 prescaler to /2\n  RCC-&gt;CFGR &= ~(1 &lt;&lt; 7); // Set AHB prescaler to /1\n  pinMode(GPIOA, 0, GPIO_OUTPUT);\n  pinMode(GPIOA, 2, GPIO_OUTPUT);\n  digitalWrite(GPIOA, 0, GPIO_HIGH);\n  //pinMode(GPIOA,1,GPIO_ALT);\n  //pinMode(GPIOA,2,GPIO_ALT);\n  initTIM(TIM15,9);\n  initTIM(TIM16,799);\n  \n  \n    \n  \n  \n\n  \n  int length = sizeof(notes) / sizeof(notes[0]);\n\n  printf(\"%d\\n\", length);  // Prints 5\n  for(int i=0; i&lt;length+1; i++){\n  uint32_t Frequency = notes[i][0];\n  uint32_t delay = notes[i][1];\n  printf(\"Frequency %d Delay %d\\n\", Frequency, delay);\n  \n  if(delay == 0){\n    break;\n  }\n  else{\n    PWM(TIM15,Frequency);\n    delay_millis(TIM16,TIM15,delay,Frequency,GPIOA,0);\n  }\n  }\n  \n  \n  \n  \n\n}\n\n/*************************** End of file ****************************/"
  },
  {
    "objectID": "labs/lab4/lab4.html#rcc-header",
    "href": "labs/lab4/lab4.html#rcc-header",
    "title": "Lab 4",
    "section": "RCC Header ",
    "text": "RCC Header \n// STM32L432KC_RCC.h\n// Header for RCC functions\n\n#ifndef STM32L4_RCC_H\n#define STM32L4_RCC_H\n\n#include &lt;stdint.h&gt;\n\n///////////////////////////////////////////////////////////////////////////////\n// Definitions\n///////////////////////////////////////////////////////////////////////////////\n\n#define __IO volatile\n\n// Base addresses\n#define RCC_BASE (0x40021000UL) // base address of RCC\n\n// PLL\n#define PLLSRC_HSI 0\n#define PLLSRC_HSE 1\n\n// Clock configuration\n#define SW_HSI  0\n#define SW_HSE  1\n#define SW_PLL  2\n\n/**\n  * @brief Reset and Clock Control\n  */\n\ntypedef struct\n{\n  __IO uint32_t CR;          /*!&lt; RCC clock control register,                                              Address offset: 0x00 */\n  __IO uint32_t ICSCR;       /*!&lt; RCC internal clock sources calibration register,                         Address offset: 0x04 */\n  __IO uint32_t CFGR;        /*!&lt; RCC clock configuration register,                                        Address offset: 0x08 */\n  __IO uint32_t PLLCFGR;     /*!&lt; RCC system PLL configuration register,                                   Address offset: 0x0C */\n  __IO uint32_t PLLSAI1CFGR; /*!&lt; RCC PLL SAI1 configuration register,                                     Address offset: 0x10 */\n  uint32_t      RESERVED;    /*!&lt; Reserved,                                                                Address offset: 0x14 */\n  __IO uint32_t CIER;        /*!&lt; RCC clock interrupt enable register,                                     Address offset: 0x18 */\n  __IO uint32_t CIFR;        /*!&lt; RCC clock interrupt flag register,                                       Address offset: 0x1C */\n  __IO uint32_t CICR;        /*!&lt; RCC clock interrupt clear register,                                      Address offset: 0x20 */\n  uint32_t      RESERVED0;   /*!&lt; Reserved,                                                                Address offset: 0x24 */\n  __IO uint32_t AHB1RSTR;    /*!&lt; RCC AHB1 peripheral reset register,                                      Address offset: 0x28 */\n  __IO uint32_t AHB2RSTR;    /*!&lt; RCC AHB2 peripheral reset register,                                      Address offset: 0x2C */\n  __IO uint32_t AHB3RSTR;    /*!&lt; RCC AHB3 peripheral reset register,                                      Address offset: 0x30 */\n  uint32_t      RESERVED1;   /*!&lt; Reserved,                                                                Address offset: 0x34 */\n  __IO uint32_t APB1RSTR1;   /*!&lt; RCC APB1 peripheral reset register 1,                                    Address offset: 0x38 */\n  __IO uint32_t APB1RSTR2;   /*!&lt; RCC APB1 peripheral reset register 2,                                    Address offset: 0x3C */\n  __IO uint32_t APB2RSTR;    /*!&lt; RCC APB2 peripheral reset register,                                      Address offset: 0x40 */\n  uint32_t      RESERVED2;   /*!&lt; Reserved,                                                                Address offset: 0x44 */\n  __IO uint32_t AHB1ENR;     /*!&lt; RCC AHB1 peripheral clocks enable register,                              Address offset: 0x48 */\n  __IO uint32_t AHB2ENR;     /*!&lt; RCC AHB2 peripheral clocks enable register,                              Address offset: 0x4C */\n  __IO uint32_t AHB3ENR;     /*!&lt; RCC AHB3 peripheral clocks enable register,                              Address offset: 0x50 */\n  uint32_t      RESERVED3;   /*!&lt; Reserved,                                                                Address offset: 0x54 */\n  __IO uint32_t APB1ENR1;    /*!&lt; RCC APB1 peripheral clocks enable register 1,                            Address offset: 0x58 */\n  __IO uint32_t APB1ENR2;    /*!&lt; RCC APB1 peripheral clocks enable register 2,                            Address offset: 0x5C */\n  __IO uint32_t APB2ENR;     /*!&lt; RCC APB2 peripheral clocks enable register,                              Address offset: 0x60 */\n  uint32_t      RESERVED4;   /*!&lt; Reserved,                                                                Address offset: 0x64 */\n  __IO uint32_t AHB1SMENR;   /*!&lt; RCC AHB1 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x68 */\n  __IO uint32_t AHB2SMENR;   /*!&lt; RCC AHB2 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x6C */\n  __IO uint32_t AHB3SMENR;   /*!&lt; RCC AHB3 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x70 */\n  uint32_t      RESERVED5;   /*!&lt; Reserved,                                                                Address offset: 0x74 */\n  __IO uint32_t APB1SMENR1;  /*!&lt; RCC APB1 peripheral clocks enable in sleep mode and stop modes register 1, Address offset: 0x78 */\n  __IO uint32_t APB1SMENR2;  /*!&lt; RCC APB1 peripheral clocks enable in sleep mode and stop modes register 2, Address offset: 0x7C */\n  __IO uint32_t APB2SMENR;   /*!&lt; RCC APB2 peripheral clocks enable in sleep mode and stop modes register, Address offset: 0x80 */\n  uint32_t      RESERVED6;   /*!&lt; Reserved,                                                                Address offset: 0x84 */\n  __IO uint32_t CCIPR;       /*!&lt; RCC peripherals independent clock configuration register,                Address offset: 0x88 */\n  uint32_t      RESERVED7;   /*!&lt; Reserved,                                                                Address offset: 0x8C */\n  __IO uint32_t BDCR;        /*!&lt; RCC backup domain control register,                                      Address offset: 0x90 */\n  __IO uint32_t CSR;         /*!&lt; RCC clock control & status register,                                     Address offset: 0x94 */\n  __IO uint32_t CRRCR;       /*!&lt; RCC clock recovery RC register,                                          Address offset: 0x98 */\n} RCC_TypeDef;\n\n#define RCC ((RCC_TypeDef *) RCC_BASE)\n\n///////////////////////////////////////////////////////////////////////////////\n// Function prototypes\n///////////////////////////////////////////////////////////////////////////////\n\nvoid configurePLL(void);\nvoid configureClock(void);\n\n#endif"
  },
  {
    "objectID": "labs/lab4/lab4.html#rcc-c-file",
    "href": "labs/lab4/lab4.html#rcc-c-file",
    "title": "Lab 4",
    "section": "RCC C File ",
    "text": "RCC C File \n// STM32L432KC_RCC.c\n// Source code for RCC functions\n\n#include \"STM32L432KC_RCC.h\"\n\nvoid configurePLL(void) {\n    // Set clock to 80 MHz\n    // Output freq = (src_clk) * (N/M) / R\n    // (4 MHz) * (80/1) / 4 = 80 MHz\n    // M: 1, N: 80, R: 4\n    // Use MSI as PLLSRC\n\n    // Turn off PLL\n    RCC-&gt;CR &= ~(1 &lt;&lt; 24);\n    \n    // Wait till PLL is unlocked (e.g., off)\n    while ((RCC-&gt;CR &gt;&gt; 25 & 1) != 0);\n\n    // Load configuration\n    // Set PLL SRC to MSI\n    RCC-&gt;PLLCFGR |= (1 &lt;&lt; 0);\n    RCC-&gt;PLLCFGR &= ~(1 &lt;&lt; 1);\n\n    // Set PLLN\n    RCC-&gt;PLLCFGR &= ~(0b11111111 &lt;&lt; 8); // Clear all bits of PLLN\n    RCC-&gt;PLLCFGR |= (0b1010000 &lt;&lt; 8); // |= 80\n    \n    // Set PLLM\n    RCC-&gt;PLLCFGR &= ~(0b111 &lt;&lt; 4);  // Clear all bits\n    \n    // Set PLLR\n    RCC-&gt;PLLCFGR &= ~(1 &lt;&lt; 26);\n    RCC-&gt;PLLCFGR |= (1 &lt;&lt; 25);\n    \n    // Enable PLLR output\n    RCC-&gt;PLLCFGR |= (1 &lt;&lt; 24);\n\n    // Enable PLL\n    RCC-&gt;CR |= (1 &lt;&lt; 24);\n    \n    // Wait until PLL is locked\n    while ((RCC-&gt;CR &gt;&gt; 25 & 1) != 1);\n}\n\nvoid configureClock(void){\n    // Configure and turn on PLL\n    configurePLL();\n\n    // Select PLL as clock source\n    RCC-&gt;CFGR |= (0b11 &lt;&lt; 0);\n    while(!((RCC-&gt;CFGR &gt;&gt; 2) & 0b11));\n}"
  },
  {
    "objectID": "labs/lab4/lab4.html#tim-15-and-16-header",
    "href": "labs/lab4/lab4.html#tim-15-and-16-header",
    "title": "Lab 4",
    "section": "Tim 15 and 16 Header ",
    "text": "Tim 15 and 16 Header \n//STM32L432KC_TIM1516.h\n//Header for TIM1516 functions\n\n#ifndef STM32L4_TIM_15_16_H\n#define STM32L4_TIM_15_16_H\n\n#include &lt;stdint.h&gt;\n#include \"STM32L432KC_GPIO.h\" // Include GPIO header for GPIO type\n#define __IO volatile\n\n//Base Address\n#define TIM16_BASE (0x40014400UL)\n#define TIM15_BASE (0x40014000UL)\n\n//Bit Field\n\ntypedef struct{\n  __IO uint32_t CR1; //0x00\n  __IO uint32_t CR2; //0x04\n  __IO uint32_t SMCR; //0x08\n  __IO uint32_t DIER; //0x0C\n  __IO uint32_t SR; //0x10\n  __IO uint32_t EGR; //0x14\n  __IO uint32_t CCMR1; //0x18\n  __IO uint32_t BLANK; //0x1C\n  __IO uint32_t CCER; //0x20\n  __IO uint32_t CNT; //0x24\n  __IO uint32_t PSC; //0x028\n  __IO uint32_t ARR; //0x2C\n  __IO uint32_t RCR; //0x30\n  __IO uint32_t CCR1; //0x34\n  __IO uint32_t CCR2; //0x38\n  __IO uint32_t BLANK1; //0x3C\n  __IO uint32_t BLANK2; //0x40\n  __IO uint32_t BDTR; //0x44\n  __IO uint32_t DCR; //0x48\n  __IO uint32_t DMAR; //0x4C\n  __IO uint32_t OR1; //0x50\n  __IO uint32_t BLANK3; //0x54\n  __IO uint32_t BLANK4; //0x5C\n  __IO uint32_t OR2; //0x60\n} TIM_1516_Typedef;\n\n#define TIM15 ((TIM_1516_Typedef *) TIM15_BASE)\n#define TIM16 ((TIM_1516_Typedef *) TIM16_BASE)\n\nvoid initTIM(TIM_1516_Typedef* TIMx,uint32_t PSC_VAL);\nvoid delay_millis(TIM_1516_Typedef * TIM1x, TIM_1516_Typedef * TIM2x,uint32_t ms,uint32_t Frequency,GPIO* GPIOx,int pin);\nvoid PWM(TIM_1516_Typedef* TIMx, uint32_t Frequency);\n\n#endif"
  },
  {
    "objectID": "labs/lab4/lab4.html#tim-15-and-16-c-file",
    "href": "labs/lab4/lab4.html#tim-15-and-16-c-file",
    "title": "Lab 4",
    "section": "Tim 15 and 16 C File ",
    "text": "Tim 15 and 16 C File \n// STM32L432KC_TIM_15_16.c\n// Source code for TIM functions\n\n#include \"STM32L432KC_TIM_15_16.h\"\n#include \"STM32L432KC_RCC.h\"\n#include \"STM32L432KC_GPIO.h\"\n\nvoid initTIM(TIM_1516_Typedef * TIMx,uint32_t PSC_VAL) {\n    TIMx-&gt;CR1 |=(1&lt;&lt;7); // Turn on ARPE\n    TIMx-&gt;PSC = PSC_VAL; // Prescaler value (40 MHz / (799 + 1) = 50 kHz)\n}\n\nvoid delay_millis(TIM_1516_Typedef * TIM1x, TIM_1516_Typedef * TIM2x,uint32_t ms,uint32_t Frequency,GPIO* GPIOx,int pin) {\n    TIM1x-&gt;ARR = ms*100; // Auto-reload value for ms delay (50 kHz clock) for PSC 799\n    printf(\"ARR is %lu\\n\",TIM1x-&gt;ARR);\n    TIM1x-&gt;EGR |= (1&lt;&lt;0); // Generate an update event \n    TIM1x-&gt;SR &= ~(1&lt;&lt;0); // Clear interrupt flag\n    TIM1x-&gt;CR1 |= (1&lt;&lt;0); // Start timer\n\n    // Wait until the update interrupt flag is set\n    while (((TIM1x-&gt;SR &gt;&gt; 0) & 1) == 0){\n        if(Frequency!=0){\n            //printf(\"CNT is %lu, ARR is %lu\\n\",TIM2x-&gt;CNT,TIM2x-&gt;ARR);\n            if(TIM2x-&gt;CNT &lt; TIM2x-&gt;ARR/2){\n                digitalWrite(GPIOx,pin,GPIO_HIGH);\n            }\n            else{\n                digitalWrite(GPIOx,pin,GPIO_LOW);\n            }\n        }   \n        else{\n            digitalWrite(GPIOx,pin,GPIO_LOW);\n        }\n    };\n\n    TIM1x-&gt;CR1 &= ~(1&lt;&lt;0); // Stop the time\n}\n\n\nvoid PWM(TIM_1516_Typedef * TIMx, uint32_t Frequency) {\n    TIMx-&gt;ARR = (8000000/(Frequency)); // Auto-reload value for ms delay (50 kHz clock)\n    TIMx-&gt;EGR |= (1&lt;&lt;0); // Generate an update event \n    TIMx-&gt;SR &= ~(1&lt;&lt;0); // Clear interrupt flag\n    TIMx-&gt;CR1 |= (1&lt;&lt;0); // Start timer\n    printf(\"ARR is %lu\\n\",TIMx-&gt;ARR);\n    \n    \n\n    \n    \n\n\n}"
  },
  {
    "objectID": "labs/lab4/lab4.html#flash-header",
    "href": "labs/lab4/lab4.html#flash-header",
    "title": "Lab 4",
    "section": "Flash Header ",
    "text": "Flash Header \n// STM32L432KC_FLASH.h\n// Header for FLASH functions\n\n#ifndef STM32L4_FLASH_H\n#define STM32L4_FLASH_H\n\n#include &lt;stdint.h&gt;\n\n///////////////////////////////////////////////////////////////////////////////\n// Definitions\n///////////////////////////////////////////////////////////////////////////////\n\n#define __IO volatile\n\n// Base addresses for GPIO ports\n#define FLASH_BASE (0x40022000UL) // base address of RCC\n\n///////////////////////////////////////////////////////////////////////////////\n// Bitfield struct for GPIO\n///////////////////////////////////////////////////////////////////////////////\n\ntypedef struct {\n  __IO uint32_t ACR;      /*!&lt; FLASH access control register,   Address offset: 0x00 */\n  __IO uint32_t KEYR;     /*!&lt; FLASH key register,              Address offset: 0x04 */\n  __IO uint32_t OPTKEYR;  /*!&lt; FLASH option key register,       Address offset: 0x08 */\n  __IO uint32_t SR;       /*!&lt; FLASH status register,           Address offset: 0x0C */\n  __IO uint32_t CR;       /*!&lt; FLASH control register,          Address offset: 0x10 */\n  __IO uint32_t OPTCR;    /*!&lt; FLASH option control register ,  Address offset: 0x14 */\n  __IO uint32_t OPTCR1;   /*!&lt; FLASH option control register 1, Address offset: 0x18 */\n} FLASH_TypeDef;\n\n#define FLASH ((FLASH_TypeDef *) FLASH_BASE)\n\n///////////////////////////////////////////////////////////////////////////////\n// Function prototypes\n///////////////////////////////////////////////////////////////////////////////\n\nvoid configureFlash(void);\n\n#endif"
  },
  {
    "objectID": "labs/lab4/lab4.html#flash-c-file",
    "href": "labs/lab4/lab4.html#flash-c-file",
    "title": "Lab 4",
    "section": "Flash C File ",
    "text": "Flash C File \n// STM32L432KC_FLASH.c\n// Source code for FLASH functions\n\n#include \"STM32L432KC_FLASH.h\"\n\nvoid configureFlash(void) {\n    FLASH-&gt;ACR |= (0b100); // Set to 4 waitstates\n    FLASH-&gt;ACR |= (1 &lt;&lt; 8); // Turn on the ART\n}"
  },
  {
    "objectID": "labs/lab4/lab4.html#gpio-header",
    "href": "labs/lab4/lab4.html#gpio-header",
    "title": "Lab 4",
    "section": "GPIO Header ",
    "text": "GPIO Header \n// STM32L432KC_GPIO.h\n// Header for GPIO functions\n\n#ifndef STM32L4_GPIO_H\n#define STM32L4_GPIO_H\n\n#include &lt;stdint.h&gt; // Include stdint header\n\n///////////////////////////////////////////////////////////////////////////////\n// Definitions\n///////////////////////////////////////////////////////////////////////////////\n\n// Values for GPIO pins (\"val\" arguments)\n#define GPIO_LOW    0\n#define GPIO_HIGH   1\n\n// Base addresses for GPIO ports\n#define GPIOB_BASE  (0x48000400UL)\n#define GPIOA_BASE  (0x48000000UL)\n\n// Arbitrary GPIO functions for pinMode()\n#define GPIO_INPUT  0\n#define GPIO_OUTPUT 1\n#define GPIO_ALT    2\n#define GPIO_ANALOG 3\n\n///////////////////////////////////////////////////////////////////////////////\n// Bitfield struct for GPIO\n///////////////////////////////////////////////////////////////////////////////\n\n// GPIO register structs here\ntypedef struct {\n    volatile uint32_t MODER;   // GPIO Offset 0x00 GPIO port mode register\n    volatile uint32_t OTYPER;  // GPIO Offset 0x04\n    volatile uint32_t OSPEEDR; // GPIO Offset 0x08\n    volatile uint32_t PURPDR;  // GPIO Offset 0x0C\n    volatile uint32_t IDR;     // GPIO Offset 0x10\n    volatile uint32_t ODR;     // GPIO Offset 0x14\n    volatile uint32_t BSRR;    // GPIO Offset 0x18\n    volatile uint32_t LCKR;    // GPIO Offset 0x1C\n    volatile uint32_t AFRL;    // GPIO Offset 0x20\n    volatile uint32_t AFRH;    // GPIO Offset 0x24\n} GPIO;\n\n// Pointers to GPIO-sized chunks of memory for each peripheral\n#define GPIOB ((GPIO *) GPIOB_BASE)\n#define GPIOA ((GPIO *) GPIOA_BASE)\n//#define GPIO GPIOB\n\n///////////////////////////////////////////////////////////////////////////////\n// Function prototypes\n///////////////////////////////////////////////////////////////////////////////\n\nvoid pinMode(GPIO* GPIOx,int pin, int function);\n\nint digitalRead(GPIO* GPIOx,int pin);\n\nvoid digitalWrite(GPIO* GPIOx,int pin, int val);\n\nvoid togglePin(GPIO* GPIOx,int pin);\n\n#endif"
  },
  {
    "objectID": "labs/lab4/lab4.html#gpio-c",
    "href": "labs/lab4/lab4.html#gpio-c",
    "title": "Lab 4",
    "section": "GPIO C ",
    "text": "GPIO C \n// STM32L432KC_GPIO.c\n// Source code for GPIO functions\n\n#include \"STM32L432KC_GPIO.h\"\n\nvoid pinMode(GPIO* GPIOx,int pin, int function) {\n    switch(function) {\n        case GPIO_INPUT:\n            GPIOx-&gt;MODER &= ~(0b11 &lt;&lt; 2*pin);\n            break;\n        case GPIO_OUTPUT:\n            GPIOx-&gt;MODER |= (0b1 &lt;&lt; 2*pin);\n            GPIOx-&gt;MODER &= ~(0b1 &lt;&lt; (2*pin+1));\n            break;\n        case GPIO_ALT:\n            //sets moder\n            GPIOx-&gt;MODER &= ~(0b1 &lt;&lt; 2*pin);\n            GPIOx-&gt;MODER |= (0b1 &lt;&lt; (2*pin+1));\n            //sets as push pull\n            //GPIOx-&gt;OTYPER |= (0b1 &lt;&lt; pin); // Push-pull\n            GPIOx-&gt;AFRL |= (0b1110 &lt;&lt; 4*pin); // Clear bits\n            break;\n        case GPIO_ANALOG:\n            GPIOx-&gt;MODER |= (0b11 &lt;&lt; 2*pin);\n            break;\n    }\n}\n\nint digitalRead(GPIO* GPIOx,int pin) {\n    return ((GPIOx-&gt;IDR) &gt;&gt; pin) & 1;\n}\n\nvoid digitalWrite(GPIO* GPIOx,int pin, int val) {\n    if(val == GPIO_LOW)\n        GPIOx-&gt;ODR &= ~(1 &lt;&lt; pin);\n    else\n    GPIOx-&gt;ODR |= (1 &lt;&lt; pin);\n}\n\nvoid togglePin(GPIO* GPIOx,int pin) {\n    // Use XOR to toggle\n    GPIOx-&gt;ODR ^= (1 &lt;&lt; pin);\n}"
  },
  {
    "objectID": "labs/lab4/lab4.html#max-min-frequency",
    "href": "labs/lab4/lab4.html#max-min-frequency",
    "title": "Lab 4",
    "section": "Max Min Frequency ",
    "text": "Max Min Frequency \n ## Error   # Notes"
  },
  {
    "objectID": "labs/lab4/lab4.html#which-timers-can-you-use",
    "href": "labs/lab4/lab4.html#which-timers-can-you-use",
    "title": "Lab 4",
    "section": "1. Which timers can you use?",
    "text": "1. Which timers can you use?\nThe STM32L432KC has several general-purpose and advanced timers:\n\nTIM1 (advanced control, 16-bit, has complementary outputs, dead-time, etc.)\nTIM2 (general-purpose, 32-bit)\nTIM15, TIM16, TIM17 (16-bit, smaller general-purpose timers)\nLPTIM1, LPTIM2 (low-power timers, good for ultra-low-frequency and low-power applications, but less flexible for PWM).\n\nüëâ For your use case (simple output waveforms at ~200 Hz‚Äì1 kHz):\n\nTIM2 is a great choice because it‚Äôs 32-bit, so you don‚Äôt need to worry about overflow.\nTIM1 or TIM15 are also good choices if you want direct PWM routing to GPIO pins with advanced features.\nIf you want the easiest connection to a GPIO pin, choose TIM2, TIM1, or TIM15, since they have well-documented alternate functions (AF) for output compare/PWM on pins."
  },
  {
    "objectID": "labs/lab4/lab4.html#how-do-you-generate-the-frequency",
    "href": "labs/lab4/lab4.html#how-do-you-generate-the-frequency",
    "title": "Lab 4",
    "section": "2. How do you generate the frequency?",
    "text": "2. How do you generate the frequency?\nA timer frequency is controlled by three things:\n[ f_{out} = ]\nWhere:\n\n(f_{TIM}) = timer clock frequency (depends on APB prescaler ‚Äî typically up to 80 MHz on STM32L432).\nPSC = prescaler register (TIMx_PSC)\nARR = auto-reload register (TIMx_ARR) ‚Üí sets the period.\n\nIf you want a PWM (toggle a pin), you set an output compare mode (via TIMx_CCMR) and choose a duty cycle using the capture/compare register (TIMx_CCRx)."
  },
  {
    "objectID": "labs/lab4/lab4.html#example-calculation",
    "href": "labs/lab4/lab4.html#example-calculation",
    "title": "Lab 4",
    "section": "3. Example Calculation",
    "text": "3. Example Calculation\nSuppose your system clock is 80 MHz and APB1 prescaler is 1 ‚Üí so (f_{TIM} = 80 MHz).\nTarget frequency = 500 Hz.\n[ (PSC+1)(ARR+1) = = = 160{,}000]\nPick something convenient:\n\nPSC = 159 ‚Üí (PSC+1) = 160\nARR = 999 ‚Üí (ARR+1) = 1000 ‚Üí Frequency = (80,MHz / (160 ) = 500,Hz).\n\nFor 220 Hz: [ (PSC+1)(ARR+1) = ] You might choose PSC = 359, ARR ‚âà 1009 ‚Üí ~220 Hz.\nFor 1 kHz: [ (PSC+1)(ARR+1) = = 80{,}000] PSC = 79, ARR = 999 ‚Üí 1 kHz."
  },
  {
    "objectID": "labs/lab4/lab4.html#key-registers-to-configure",
    "href": "labs/lab4/lab4.html#key-registers-to-configure",
    "title": "Lab 4",
    "section": "4. Key Registers to Configure",
    "text": "4. Key Registers to Configure\n\nEnable clock to timer\n\nRCC_APB1ENR1 (for TIM2, TIM15, etc.)\nRCC_APB2ENR (for TIM1).\n\nSet prescaler\n\nTIMx_PSC = value.\n\nSet auto-reload register (period)\n\nTIMx_ARR = value.\n\nEnable output compare/PWM mode\n\nConfigure TIMx_CCMR1 (or CCMR2 depending on channel).\nSet channel to PWM mode 1 or 2.\n\nSet duty cycle\n\nTIMx_CCRx = value (between 0 and ARR).\n\nEnable output pin\n\nConfigure GPIO pin to AF mode with the right AF mapping for your chosen timer/channel.\nSet TIMx_CCER bit to enable the channel output.\n\nEnable counter\n\nSet TIMx_CR1.CEN = 1."
  },
  {
    "objectID": "labs/lab4/lab4.html#summary-recommendation",
    "href": "labs/lab4/lab4.html#summary-recommendation",
    "title": "Lab 4",
    "section": "5. Summary Recommendation",
    "text": "5. Summary Recommendation\n\nUse TIM2 if you want flexibility (32-bit, simple).\nUse TIM1 or TIM15 if you specifically want advanced PWM features (e.g., complementary outputs).\nConnect to GPIO via alternate function mapping (check STM32L432 datasheet for AF mappings).\n\n\nüëâ If you‚Äôd like, I can write out a bare-metal register configuration example (C code) for, say, TIM2 CH1 on a specific GPIO pin (PA0), generating 500 Hz PWM. Do you want me to write out that code?"
  },
  {
    "objectID": "labs/lab4/lab4.html#ai-reflection",
    "href": "labs/lab4/lab4.html#ai-reflection",
    "title": "Lab 4",
    "section": "AI reflection",
    "text": "AI reflection\nThe AI response compared to my own decision making was very similar. We both Identified that Timmers 15 could directly connect to gpio pins. However it doesn‚Äôt mention timmers 6 and 7.\nThe equation it gave were semi useful but was better was the foot note explaining how to program the pwm using output compare mode.\nIt has the same logic path as mine. However the way it tries to go is directly output the pwm wave to gpio pin. They miss parts about setting the polarity for the output enabling gpio pins and clocks."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2",
    "section": "",
    "text": "Introduction\nSchematic\nBlock Diagram\nVerilog Code 4.1 top 4.2 seven_seg_display 4.3 clock_divider\nTest Benches 5.1 testbench 5.2 seven_testbench\nNotes\n\n7.AI Prototype"
  },
  {
    "objectID": "labs/lab2/lab2.html#top",
    "href": "labs/lab2/lab2.html#top",
    "title": "Lab 2",
    "section": "top ",
    "text": "top \n/*\nTitle: top module for lab 2\nAuthor: Kanoa Parker\nEmail: kanparker@g.hmc.edu\nDate: 9/9/2024\nDescription: Top module for lab 2. Takes in inputs of 2 sets of 4 switches, s1 and s2. Outputs the sum of s1 and s2 as led. Using a time multiplexer the mux choses either to output either s1 or s2 as seg using seven_seg_display module. gate1 and gate1 go to transistor gates which control which set of leds get turned on.\n*/\nmodule top(\n    input logic [3:0]s1,\n    input logic [3:0]s2,\n    output logic [6:0]seg, \n    output logic [4:0]led,\n    output logic gate1, gate2,\n    output logic clk\n);\n    //s1 is inputs of one set of 4 dip swithces\n    //s2 is inputs of other set of 4 dip switches\n    //seg is the output to drive seven segment display\n    // gate1 and gate2 go to base of BJT to control power to seven segment display\n    // clk is output used for testing\n    \n    //sev_seg_in is the input to seven_seg_display module\n    logic [3:0]sev_seg_in;\n    \n    //sev_seg_out is the output of seven_seg_display module\n    logic [6:0]sev_seg_out;\n\n    //instancing seven_seg_display\n    seven_seg_display seven_seg_counter(sev_seg_in,seg);\n    //instancing clock divider\n    clock_divider slow_clock(clk);\n    \n    //muxing between s1 and s2\n    always_comb\n        case(clk)\n            1'b1: begin\n                    sev_seg_in = s1[3:0]; \n                    gate1 = 1'b1;\n                    gate2 =1'b0;\n                end\n            1'b0: begin\n                    sev_seg_in = s2[3:0];\n                    gate1 = 1'b0;\n                    gate2 = 1'b1;\n                end\n        endcase\n    //sum of s1 and s2 to led   \n        assign led = s1 + s2;\n        \nendmodule\nTop module for lab 2. Takes in inputs of 2 sets of 4 switches, s1 and s2. Outputs the sum of s1 and s2 as led. Using a time multiplexer the mux choses either to output either s1 or s2 as seg using seven_seg_display module. gate1 and gate1 go to transistor gates which control which set of leds get turned on."
  },
  {
    "objectID": "labs/lab2/lab2.html#seven_segment_display",
    "href": "labs/lab2/lab2.html#seven_segment_display",
    "title": "Lab 2",
    "section": "seven_segment_display ",
    "text": "seven_segment_display \n/*\nTitle: seven_seg_display\nAuthor: Kanoa Parker\nEmail: kanparker@g.hmc.edu\nDate: 9/9/2024\nDescription: Takes in 4 switch inputs and outputs control signal for a seven segment display\n*/\nmodule seven_seg_display(\n    input   logic   [3:0]s,\n    output  logic [6:0]seg\n);\n    //logic used for old boolean algebra method\n    logic A,B,C,D;\n    \n    assign A = s[3];\n    assign B = s[2];\n    assign C = s[1];\n    assign D = s[0];\n    \n    //old boolean algrebra method\n    /*\n    assign seg[6] = (~A&~C)&(B^D) | A&(~B&C&D | B&~C);\n    assign seg[5] = D&~(A^C) | B&(C&~D | A&~C&~D);\n    assign seg[4] = ~A&~B&C&~D | (A&B)&( ~C&~D | C);\n    assign seg[3] = (~A&D)& ~(B^C) | (A&~B)&(C^D) | B&( ~(A|C|D) | A&C&D);\n    assign seg[2] = (~A&~B&D) | (~A&B&~C) | (~A&B&C&D) | (A&~B&~C&D);\n    assign seg[1] = (~(A|B|C) & D) | (~A&~B&C) | (~A&B&C&D) | (A&B&~C);\n    assign seg[0] = ~(A|B|C|D) | (~A&~B&~C&D) | (~A&B&C&D);\n    */\n    \n    //case statement that map input to output\n    always_comb\n        case(s[3:0])\n            /// 0\n            4'b0000: seg[6:0] = 7'b0000001;\n            /// 1\n            4'b0001: seg[6:0] = 7'b1001111;\n            /// 2\n            4'b0010: seg[6:0] = 7'b0010010;\n            /// 3\n            4'b0011:seg[6:0] = 7'b0000110;\n            /// 4\n            4'b0100:seg[6:0] = 7'b1001100;\n            /// 5\n            4'b0101:seg[6:0] = 7'b0100100;\n            /// 6\n            4'b0110:seg[6:0] = 7'b0100000;\n            /// 7\n            4'b0111:seg[6:0] = 7'b0001111;\n            /// 8\n            4'b1000:seg[6:0] = 7'b0000000;\n            /// 9\n            4'b1001:seg[6:0] = 7'b0001100;\n            /// A\n            4'b1010:seg[6:0] = 7'b0001000;\n            /// B\n            4'b1011:seg[6:0] = 7'b1100000;\n            /// C\n            4'b1100:seg[6:0] = 7'b0110001;\n            /// D\n            4'b1101:seg[6:0] = 7'b1000010;\n            /// E\n            4'b1110:seg[6:0] = 7'b0110000;\n            /// F\n            4'b1111:seg[6:0] = 7'b0111000;\n        endcase\n            \n    //see notes for segment conrispondice to led\n\nendmodule\nSeven segment display takes an input of four switches, s[3:0], and ouputs to light up the seven segment display, seg[6:0]"
  },
  {
    "objectID": "labs/lab2/lab2.html#clock_divider",
    "href": "labs/lab2/lab2.html#clock_divider",
    "title": "Lab 2",
    "section": "clock_divider ",
    "text": "clock_divider \n/*\nTitle: clock_divider\nAuthor: Kanoa Parker\nEmail: kanparker@g.hmc.edu\nDate: 9/9/2024\nDescription: Takes in the standard oscillator adn divides the clock using a counter to produce a clock at desired frequency\n*/\n\nmodule clock_divider(\n    output clk\n);\n    \n    logic int_osc;\n    logic pulse;\n    logic led_state = 0;\n    logic [31:0] counter = 0;\n    logic [31:0] P;\n    \n    assign P = 32'b00000000000000010101111110010000;\n    \n    // Internal high-speed oscillator\n    HSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(int_osc));\n    \n    // Simple clock divider\n    always_ff @(posedge int_osc)\n        begin\n            counter &lt;= counter + P;\n        end\n    assign clk = counter[31];\n        \nendmodule\nTakes in the standard oscillator adn divides the clock using a counter to produce a clock at desired frequency."
  },
  {
    "objectID": "labs/lab2/lab2.html#test_bench",
    "href": "labs/lab2/lab2.html#test_bench",
    "title": "Lab 2",
    "section": "test_bench ",
    "text": "test_bench \n Link to Test Bench File"
  },
  {
    "objectID": "labs/lab2/lab2.html#seven_testbench",
    "href": "labs/lab2/lab2.html#seven_testbench",
    "title": "Lab 2",
    "section": "seven_testbench ",
    "text": "seven_testbench \n Link to Test Bench File"
  },
  {
    "objectID": "labs/lab2/lab2.html#code-ai-provided-first-try",
    "href": "labs/lab2/lab2.html#code-ai-provided-first-try",
    "title": "Lab 2",
    "section": "Code AI Provided first try",
    "text": "Code AI Provided first try\nmodule time_multiplexed_decoder (\n    input logic clk,               // Clock signal\n    input logic rst_n,             // Active-low reset signal\n    input logic [3:0] input_bits_1, // First set of 4-bit input\n    input logic [3:0] input_bits_2, // Second set of 4-bit input\n    output logic [6:0] seg_out_1,   // 7-segment output for the first set\n    output logic [6:0] seg_out_2    // 7-segment output for the second set\n);\n\n    // 7-segment display encoding for common anode (active low segments)\n    // Assuming the 7 segments are ordered as ABCDEF-G\n    logic [6:0] seven_seg_decoder [15:0] = {\n        7'b1111110,  // 0\n        7'b0110000,  // 1\n        7'b1101101,  // 2\n        7'b1111001,  // 3\n        7'b0110011,  // 4\n        7'b1011011,  // 5\n        7'b1011111,  // 6\n        7'b1110000,  // 7\n        7'b1111111,  // 8\n        7'b1111011,  // 9\n        7'b1110111,  // A\n        7'b0011111,  // B\n        7'b1001110,  // C\n        7'b0111101,  // D\n        7'b1001111,  // E\n        7'b1000111   // F\n    };\n\n    // Internal signals for multiplexing control\n    logic mux_ctrl;  // Control signal to alternate between the two sets\n\n    // Time multiplexing logic to alternate between the two sets of inputs\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            mux_ctrl &lt;= 0;  // Reset control signal\n        end else begin\n            mux_ctrl &lt;= ~mux_ctrl;  // Toggle the control signal\n        end\n    end\n\n    // Drive the seven-segment display outputs based on the multiplexed input\n    always_comb begin\n        if (mux_ctrl) begin\n            // Decode the first set of input bits\n            seg_out_1 = seven_seg_decoder[input_bits_1];\n            seg_out_2 = 7'b1111111;  // Turn off second display\n        end else begin\n            // Decode the second set of input bits\n            seg_out_2 = seven_seg_decoder[input_bits_2];\n            seg_out_1 = 7'b1111111;  // Turn off first display\n        end\n    end\n\nendmodule\nThis code was provided without my files. It all compiled and this is the netlist analyzer \n##Code AI provided given my files\n// timescale optional for simulation\n`timescale 1ns/1ps\n\n// Time-multiplex one seven-seg decoder across two inputs to drive two 7-bit busses.\n// Assumes your decoder module is named `seven_seg_display` with ports .s[3:0] and .seg[6:0],\n// and that your clock source is `clock_divider` with port .clk.\nmodule sevenseg_dual_mux #(\n    // If your seven-seg is common-anode (active-low segments), leave ACTIVE_LOW=1.\n    // If it‚Äôs common-cathode (active-high segments), set ACTIVE_LOW=0.\n    parameter bit ACTIVE_LOW = 1\n) (\n    input  logic [3:0] s1,        // first 4-bit value\n    input  logic [3:0] s2,        // second 4-bit value\n    output logic [6:0] seg1,      // seven outputs for display 1\n    output logic [6:0] seg2       // seven outputs for display 2\n);\n\n    // -------------------------------------------------------------------------\n    // Clock to flip which input is shown (multiplex rate is set inside clock_divider)\n    // -------------------------------------------------------------------------\n    logic clk_mux;\n    clock_divider u_div (.clk(clk_mux));\n\n    // -------------------------------------------------------------------------\n    // Shared decoder: one instance, two inputs selected by a toggle\n    // -------------------------------------------------------------------------\n    logic        sel;          // which input is currently active\n    logic [3:0]  nibble;       // goes into the shared decoder\n    logic [6:0]  seg_raw;      // comes out of the shared decoder\n\n    // Simple toggle at the divided clock to alternate inputs\n    always_ff @(posedge clk_mux) begin\n        sel &lt;= ~sel;\n    end\n\n    // The single decoder\n    seven_seg_display u_dec (\n        .s   (nibble),\n        .seg (seg_raw)\n    );\n\n    // -------------------------------------------------------------------------\n    // Demultiplex the decoded segments to two 7-bit outputs.\n    // The non-selected display is driven \"blank\" to avoid ghosting.\n    // For active-low segments, \"blank\" = all 1s; for active-high, \"blank\" = all 0s.\n    // -------------------------------------------------------------------------\n    localparam logic [6:0] BLANK = (ACTIVE_LOW) ? 7'b111_1111 : 7'b000_0000;\n\n    always_comb begin\n        // Default blank both\n        seg1  = BLANK;\n        seg2  = BLANK;\n\n        // Select which input feeds the decoder\n        nibble = sel ? s1 : s2;\n\n        // And route the decoder outputs to the selected display\n        if (sel) begin\n            seg1 = seg_raw;\n        end else begin\n            seg2 = seg_raw;\n        end\n    end\n\nendmodule\nCode failed with error ‚Äú0Runing Export Files failed‚Äù"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Hi im Kanoa Parker and this is my Portfolio. I‚Äôm a senior engineering major at Harvey Mudd College focusing in Electrical Engineering. In my free time I like to listen to music. Here is my LinkedIN\nThis is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Hello Quarto\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 29, 205\n\n\nKanoa Parker\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1",
    "section": "",
    "text": "Introduction\nSchematic\nBlock Diagram\nVerilog Code 4.1 top 4.2 seven_segment_display 4.3 three_led\nTest Benches 5.1 testbench 5.2 seven_testbench 5.3 three_testbench\nNotes\nAI Prototype"
  },
  {
    "objectID": "labs/lab1/lab1.html#top",
    "href": "labs/lab1/lab1.html#top",
    "title": "Lab 1",
    "section": "top ",
    "text": "top \nmodule top(\n    input   logic   [3:0]s,\n    output  logic [2:0]led,\n    output logic [6:0]seg\n);\n    //top module for lab1\n    three_led three(s, led);\n    seven_seg_display seven(s,seg);\n    \n    \n\nendmodule\nTop level module."
  },
  {
    "objectID": "labs/lab1/lab1.html#seven_segment_display",
    "href": "labs/lab1/lab1.html#seven_segment_display",
    "title": "Lab 1",
    "section": "seven_segment_display ",
    "text": "seven_segment_display \nmodule seven_seg_display(\n    input   logic   [3:0]s,\n    output  logic [6:0]seg\n);\n    //Seven segment display based on switch inputs, s[3:0] are input switches and seg[6:0] are for each segment of the display\n\n    logic A,B,C,D;\n    \n    assign A = s[3];\n    assign B = s[2];\n    assign C = s[1];\n    assign D = s[0];\n    \n    always_comb\n        case(s[3:0])\n            /// 0\n            4'b0000: seg[6:0] = 7'b0000001;\n            /// 1\n            4'b0001: seg[6:0] = 7'b1001111;\n            /// 2\n            4'b0010: seg[6:0] = 7'b0010010;\n            /// 3\n            4'b0011:seg[6:0] = 7'b0000110;\n            /// 4\n            4'b0100:seg[6:0] = 7'b1001100;\n            /// 5\n            4'b0101:seg[6:0] = 7'b0100100;\n            /// 6\n            4'b0110:seg[6:0] = 7'b0100000;\n            /// 7\n            4'b0111:seg[6:0] = 7'b0001111;\n            /// 8\n            4'b1000:seg[6:0] = 7'b0000000;\n            /// 9\n            4'b1001:seg[6:0] = 7'b0001100;\n            /// A\n            4'b1010:seg[6:0] = 7'b0001000;\n            /// B\n            4'b1011:seg[6:0] = 7'b1100000;\n            /// C\n            4'b1100:seg[6:0] = 7'b0110001;\n            /// D\n            4'b1101:seg[6:0] = 7'b1000010;\n            /// E\n            4'b1110:seg[6:0] = 7'b0110000;\n            /// F\n            4'b1111:seg[6:0] = 7'b0111000;\n        endcase\n            \n    \n\nendmodule\nSeven segment display takes an input of four switches, s[3:0], and ouputs to light up the seven segment display, seg[6:0]"
  },
  {
    "objectID": "labs/lab1/lab1.html#three_led",
    "href": "labs/lab1/lab1.html#three_led",
    "title": "Lab 1",
    "section": "three_led ",
    "text": "three_led \nmodule three_led(\n    input   logic   [3:0]s,\n    output  logic [2:0]led\n);\n    // Three led takes in an input of four switches, s[3:0], and turns on or off leds, led[2:0].\n\n    logic int_osc;\n    logic pulse;\n    logic led_state = 0;\n    logic [31:0] counter = 0;\n    logic [31:0] P;\n    \n    assign P = 32'b00000000000000000000000011010111;\n    \n    // Internal high-speed oscillator\n    HSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(int_osc));\n    \n    // Simple clock divider\n    always_ff @(posedge int_osc)\n        begin\n            counter &lt;= counter + P;\n        end\n    \n    xor x1(led[0],s[1],s[0]);\n    and a1(led[1],s[3],s[2]);\n    \n    assign led[2] = counter[31];\n    \n\nendmodule\nThree led takes in an input of four switches, s[3:0], and turns on or off leds, led[2:0]."
  },
  {
    "objectID": "labs/lab1/lab1.html#test_bench",
    "href": "labs/lab1/lab1.html#test_bench",
    "title": "Lab 1",
    "section": "test_bench ",
    "text": "test_bench \n Link to Test Bench File"
  },
  {
    "objectID": "labs/lab1/lab1.html#seven_testbench",
    "href": "labs/lab1/lab1.html#seven_testbench",
    "title": "Lab 1",
    "section": "seven_testbench ",
    "text": "seven_testbench \n Link to Test Bench File"
  },
  {
    "objectID": "labs/lab1/lab1.html#three_testbench",
    "href": "labs/lab1/lab1.html#three_testbench",
    "title": "Lab 1",
    "section": "three_testbench ",
    "text": "three_testbench \n Link to Test Bench File"
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3",
    "section": "",
    "text": "Lab 3 tbd"
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5",
    "section": "",
    "text": "Introduction\nSchematic\nFlow Chart\nC Code 4.1 main 4.2 EXTI0_IRQHandler 4.3 EXTI1_IRQHandler 4.4 interupt_setup\nCalculation\nComparison of Manual vs Interupts\nAI Prototype"
  },
  {
    "objectID": "labs/lab5/lab5.html#main",
    "href": "labs/lab5/lab5.html#main",
    "title": "Lab 5",
    "section": "main ",
    "text": "main \nint main(void) {\n    pinMode(PA2,GPIO_OUTPUT);\n    printf(\"Sequence Start\\n\");\n    int volatile n = 0;\n\n    // Set system clock to 80 MHz\n    //configureClock();\n    //configurePLL();\n    //printf(\"Clock Configure\\n\");\n\n    // Enable button as input\n    gpioEnable(GPIO_PORT_A);\n    printf(\"Gpio Enable\\n\");\n    pinMode(PA0, GPIO_INPUT);\n    pinMode(PA1, GPIO_INPUT);\n    pinMode(PA2, GPIO_OUTPUT);\n    printf(\"Pinmode\\n\");\n    GPIOA-&gt;PUPDR |= _VAL2FLD(GPIO_PUPDR_PUPD0, 0b10); // Set PA0 as pull down\n    GPIOA-&gt;PUPDR |= _VAL2FLD(GPIO_PUPDR_PUPD1, 0b10); // Set PA1 as pull down\n    printf(\"Pull Up and Down\\n\");\n\n    // Initialize timer\n    RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;\n    initTIM(DELAY_TIM);\n    printf(\"Timer Initialize\\n\");\n\n    //set up interupts\n    interupt_set();\n    printf(\"Interupt Set\\n\");\n    \n    int volatile leadA;\n    printf(\"Volatile A Set\\n\");\n    int volatile leadB;\n    printf(\"Hit While Loop\\n\");\n    int volatile nn=0;\n    \n    digitalWrite(PA2,PIO_HIGH);\n    while(1){\n        \n\n        //interupt handler\n        EXTI0_IRQHandler();\n        EXTI1_IRQHandler();\n        \n        \n        //calculate speed\n        \n        //write to serial if it has been a second\n        if (write_counter==1000) {\n            speed = (float)(A_count + B_count)/(816.0*2); \n            printf(\"Current Speed is %f REV/s\\n\", speed);\n            write_counter = 0;\n            printf(\"Acount %d Bcount %d \\n\", A_count, B_count);\n            A_count = 0;\n            B_count = 0;\n            printf(\"%d \\n\", nn);\n            nn = nn+1;\n            \n        }\n        \n        //delay and increment counter\n        delay_millis(TIM2,1);\n        write_counter = (write_counter + 1);\n        //printf(\"%d \\n\", write_counter);\n        togglePin(PA2);\n        \n        \n\n    }\n}\nMain Module.\nLink to github with full list of library and header files. Link to Git Hub."
  },
  {
    "objectID": "labs/lab5/lab5.html#exti0_irqhandler",
    "href": "labs/lab5/lab5.html#exti0_irqhandler",
    "title": "Lab 5",
    "section": "EXTI0_IRQHandler ",
    "text": "EXTI0_IRQHandler \nvoid EXTI1_IRQHandler(void) {\n    //read the leads\n    int leadA = digitalRead(PA0);\n    int leadB = digitalRead(PA1);\n    // Check that the button was what triggered our interrupt\n    if (EXTI-&gt;PR1 & (1 &lt;&lt; gpioPinOffset(PA1))){\n        // If so, clear the interrupt (NB: Write 1 to reset.)\n        EXTI-&gt;PR1 |= (1 &lt;&lt; gpioPinOffset(PA1));\n        //Rising Edge\n        if(leadB == 1){\n            //check direction\n            if(leadA ==1){\n                B_count = B_count + 1;\n            }\n            else{\n                B_count = B_count - 1;\n            }\n        }\n        //Falling Edge\n        else{\n            if(leadA ==0){\n                B_count = B_count + 1;\n            }\n            else{\n                B_count = B_count - 1;\n            }\n        }\n    }\n}\nInterupt handler for EXTI0 which is connected to the encoder signal A."
  },
  {
    "objectID": "labs/lab5/lab5.html#exti1_irqhandler",
    "href": "labs/lab5/lab5.html#exti1_irqhandler",
    "title": "Lab 5",
    "section": "EXTI1_IRQHandler ",
    "text": "EXTI1_IRQHandler \nvoid EXTI0_IRQHandler(void) {\n    // Check that the button was what triggered our interrupt\n    int leadA = digitalRead(PA0);\n    int leadB = digitalRead(PA1);\n    if (EXTI-&gt;PR1 & (1 &lt;&lt; gpioPinOffset(PA0))){\n        // If so, clear the interrupt (NB: Write 1 to reset.)\n        EXTI-&gt;PR1 |= (1 &lt;&lt; gpioPinOffset(PA0));\n        //Rising Edge\n        if(leadA == 1){\n            //check direction\n            if(leadB ==0){\n                A_count = A_count + 1;\n            }\n            else{\n                A_count = A_count - 1;\n            }\n        }\n        //Falling Edge\n        else{\n            if(leadB ==0){\n                A_count = A_count - 1;\n            }\n            else{\n                A_count = A_count + 1;\n            }\n        }\n    }\n}\nInterupt handler for EXTI0 which is connected to the encoder signal A."
  },
  {
    "objectID": "labs/lab5/lab5.html#interupt_setup",
    "href": "labs/lab5/lab5.html#interupt_setup",
    "title": "Lab 5",
    "section": "interupt_setup",
    "text": "interupt_setup\nint interupt_set(void) {\n    // 1. Enable SYSCFG clock domain in RCC\n    RCC-&gt;APB2ENR |= RCC_APB2ENR_SYSCFGEN;\n    // 2. Configure EXTICR for the input button interrupt\n    SYSCFG-&gt;EXTICR[1] |= _VAL2FLD(SYSCFG_EXTICR1_EXTI0, 0b000); // Select PA0\n    SYSCFG-&gt;EXTICR[1] |= _VAL2FLD(SYSCFG_EXTICR1_EXTI1, 0b000); // Select PA1\n\n    \n\n    // Configure interrupt for falling and rising edge of GPIO pin for button\n    // 1. Configure mask bit\n    EXTI-&gt;IMR1 |= (1 &lt;&lt; gpioPinOffset(PA0)); // Configure the mask bit\n    EXTI-&gt;IMR1 |= (1 &lt;&lt; gpioPinOffset(PA1)); // Configure the mask bit\n\n    // 2. Enable rising edge trigger\n    EXTI-&gt;RTSR1 |= (1 &lt;&lt; gpioPinOffset(PA0));// Disable rising edge trigger\n    EXTI-&gt;RTSR1 |= (1 &lt;&lt; gpioPinOffset(PA1));// Disable rising edge trigger\n\n    // 3. Enable falling edge trigger\n    EXTI-&gt;FTSR1 |= (1 &lt;&lt; gpioPinOffset(PA0));// Enable falling edge trigger\n    EXTI-&gt;FTSR1 |= (1 &lt;&lt; gpioPinOffset(PA1));// Enable falling edge trigger\n\n    // 4. Turn on EXTI interrupt in NVIC_ISER\n    NVIC-&gt;ISER[0] |= (1 &lt;&lt; EXTI0_IRQn);\n    NVIC-&gt;ISER[0] |= (1 &lt;&lt; EXTI1_IRQn);\n    \n    // Enable interrupts globally\n    __enable_irq();\n    \n}\nInterupt setup and handle."
  },
  {
    "objectID": "labs/lab7/lab7.html",
    "href": "labs/lab7/lab7.html",
    "title": "Lab 7",
    "section": "",
    "text": "Lab 7 tbd"
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Hello Quarto",
    "section": "",
    "text": "My goals for this semster in micro p‚Äôs is to learn as much as I can. I want to get into a good work flow schedule and manage my time well. I think I can achieve this by setting aside specific time to do work and staying focused. We will see"
  },
  {
    "objectID": "labs/lab1/lab1.html#reflection",
    "href": "labs/lab1/lab1.html#reflection",
    "title": "Lab 1",
    "section": "Reflection",
    "text": "Reflection\nThe code synthesized well and completed with no errors. The quality overall is pretty decent work however it uses a lot more advance features than what we have covered in class so far. It uses a lot of localparam in unsigned vs just having what I did which was logic and it uses integers vs what I used which was all binary which seems that he LLM made it more readable. Overall it is pretty straight forward just syntaxing is a little unfamilar.\nHow would you rate the quality of the output and why? What SystemVerilog constructs/syntax did the LLM generated that were new to you? Did the LLM-generated code synthesize the first time around? If not, what were the issues? What error or warning messages did Radiant output? What would you do differently the next time you use an LLM in your workflow?"
  }
]
[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Resources",
    "section": "",
    "text": "Link to E155 Resources"
  },
  {
    "objectID": "labss.html",
    "href": "labss.html",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab 1\n\n\nProgramming a Seven Segment display and 3 LEDs with Combinational Logic\n\n\n\n\n\nSep 2, 2025\n\n\nKanoa Parker\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2\n\n\nProgramming a Dual Seven Segment display controlled by 2 sets of 4 dipswitches. Using a time multiplexer the inputs from four switches control one half of the display. In addition 5 leds indicate the sum of the two sets of 4 dip switches.\n\n\n\n\n\nSep 9, 2025\n\n\nKanoa Parker\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3\n\n\nLab 3\n\n\n\n\n\nAug 29, 205\n\n\nKanoa Parker\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4\n\n\nProgramming a STM32L432KC Microcontroller to output a PWM wave at specific freqeuncies and at specific durations in order to drive a speaker.\n\n\n\n\n\nSep 30, 2025\n\n\nKanoa Parker\n\n\n\n\n\n\n\n\n\n\n\n\nLab 5\n\n\nLab 5\n\n\n\n\n\nAug 29, 205\n\n\nKanoa Parker\n\n\n\n\n\n\n\n\n\n\n\n\nLab 6\n\n\nLab 6\n\n\n\n\n\nAug 29, 205\n\n\nKanoa Parker\n\n\n\n\n\n\n\n\n\n\n\n\nLab 7\n\n\nLab 7\n\n\n\n\n\nAug 29, 205\n\n\nKanoa Parker\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6",
    "section": "",
    "text": "Lab 2 tbd"
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4",
    "section": "",
    "text": "Introduction\nSchematic\nMCU Code 4.1 main 4.2 RCC Header 4.3 RCC C File 4.4 TIM 15 and TIM 16 Header 4.5 TIM 15 and TIM 16 C File 4.6 Flash Header 4.7 Flash C File 4.8 GPIO Header 4.9 GPIO C File\nCalculations 5.1 Max Min Delay 5.2 Max Min Frequency 5.2 Error\nNotes\n\n7.AI Prototype"
  },
  {
    "objectID": "labs/lab4/lab4.html#main",
    "href": "labs/lab4/lab4.html#main",
    "title": "Lab 4",
    "section": "main ",
    "text": "main \n/*********************************************************************\n*                    SEGGER Microcontroller GmbH                     *\n*                        The Embedded Experts                        *\n**********************************************************************\n\n-------------------------- END-OF-HEADER -----------------------------\n\nFile    : main.c\nPurpose : Main Header File to Play Song on 8 Ohm speaker\nAuthor: Kanoa Pakrer\nEmail: kanparker@g.hmc.edu\n*/\n\n#include &lt;stdio.h&gt;\n\n/*********************************************************************\n*\n*       main()\n*\n*  Function description\n*   Application entry point.\n*/\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_RCC.h\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_RCC.c\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_TIM_15_16.h\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_TIM_15_16.c\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_GPIO.h\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_GPIO.c\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_FLASH.h\"\n#include \"C:\\Users\\kanoa\\Documents\\tutorial-clock-configuration\\lib\\STM32L432KC_FLASH.c\"\n\nconst int notes[][2] = {\n{659,   125},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{494,   125},\n{587,   125},\n{523,   125},\n{440,   250},\n{  0,   125},\n{262,   125},\n{330,   125},\n{440,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{416,   125},\n{494,   125},\n{523,   250},\n{  0,   125},\n{330,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{494,   125},\n{587,   125},\n{523,   125},\n{440,   250},\n{  0,   125},\n{262,   125},\n{330,   125},\n{440,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{523,   125},\n{494,   125},\n{440,   250},\n{  0,   125},\n{494,   125},\n{523,   125},\n{587,   125},\n{659,   375},\n{392,   125},\n{699,   125},\n{659,   125},\n{587,   375},\n{349,   125},\n{659,   125},\n{587,   125},\n{523,   375},\n{330,   125},\n{587,   125},\n{523,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{659,   125},\n{  0,   250},\n{659,   125},\n{1319,  125},\n{  0,   250},\n{623,   125},\n{659,   125},\n{  0,   250},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{494,   125},\n{587,   125},\n{523,   125},\n{440,   250},\n{  0,   125},\n{262,   125},\n{330,   125},\n{440,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{416,   125},\n{494,   125},\n{523,   250},\n{  0,   125},\n{330,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{494,   125},\n{587,   125},\n{523,   125},\n{440,   250},\n{  0,   125},\n{262,   125},\n{330,   125},\n{440,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{523,   125},\n{494,   125},\n{440,   500},\n{  0,   0}};\n\nint main(void) {\n  configureFlash();\n  configureClock();\n  RCC-&gt;AHB2ENR |=(1&lt;&lt;0);\n  RCC-&gt;APB2ENR |= (1 &lt;&lt; 16);\n  RCC-&gt;APB2ENR |= (1 &lt;&lt; 17); // Enable TIM15 and TIM16 clocks\n  RCC-&gt;CFGR &= ~(1 &lt;&lt; 13); // Set APB2 prescaler to /2\n  RCC-&gt;CFGR &= ~(1 &lt;&lt; 7); // Set AHB prescaler to /1\n  pinMode(GPIOA, 0, GPIO_OUTPUT);\n  pinMode(GPIOA, 2, GPIO_OUTPUT);\n  digitalWrite(GPIOA, 0, GPIO_HIGH);\n  //pinMode(GPIOA,1,GPIO_ALT);\n  //pinMode(GPIOA,2,GPIO_ALT);\n  initTIM(TIM15,9);\n  initTIM(TIM16,799);\n  \n  \n    \n  \n  \n\n  \n  int length = sizeof(notes) / sizeof(notes[0]);\n\n  printf(\"%d\\n\", length);  // Prints 5\n  for(int i=0; i&lt;length+1; i++){\n  uint32_t Frequency = notes[i][0];\n  uint32_t delay = notes[i][1];\n  printf(\"Frequency %d Delay %d\\n\", Frequency, delay);\n  \n  if(delay == 0){\n    break;\n  }\n  else{\n    PWM(TIM15,Frequency);\n    delay_millis(TIM16,TIM15,delay,Frequency,GPIOA,0);\n  }\n  }\n  \n  \n  \n  \n\n}\n\n/*************************** End of file ****************************/"
  },
  {
    "objectID": "labs/lab4/lab4.html#rcc-header",
    "href": "labs/lab4/lab4.html#rcc-header",
    "title": "Lab 4",
    "section": "RCC Header ",
    "text": "RCC Header \n// STM32L432KC_RCC.h\n// Header for RCC functions\n\n#ifndef STM32L4_RCC_H\n#define STM32L4_RCC_H\n\n#include &lt;stdint.h&gt;\n\n///////////////////////////////////////////////////////////////////////////////\n// Definitions\n///////////////////////////////////////////////////////////////////////////////\n\n#define __IO volatile\n\n// Base addresses\n#define RCC_BASE (0x40021000UL) // base address of RCC\n\n// PLL\n#define PLLSRC_HSI 0\n#define PLLSRC_HSE 1\n\n// Clock configuration\n#define SW_HSI  0\n#define SW_HSE  1\n#define SW_PLL  2\n\n/**\n  * @brief Reset and Clock Control\n  */\n\ntypedef struct\n{\n  __IO uint32_t CR;          /*!&lt; RCC clock control register,                                              Address offset: 0x00 */\n  __IO uint32_t ICSCR;       /*!&lt; RCC internal clock sources calibration register,                         Address offset: 0x04 */\n  __IO uint32_t CFGR;        /*!&lt; RCC clock configuration register,                                        Address offset: 0x08 */\n  __IO uint32_t PLLCFGR;     /*!&lt; RCC system PLL configuration register,                                   Address offset: 0x0C */\n  __IO uint32_t PLLSAI1CFGR; /*!&lt; RCC PLL SAI1 configuration register,                                     Address offset: 0x10 */\n  uint32_t      RESERVED;    /*!&lt; Reserved,                                                                Address offset: 0x14 */\n  __IO uint32_t CIER;        /*!&lt; RCC clock interrupt enable register,                                     Address offset: 0x18 */\n  __IO uint32_t CIFR;        /*!&lt; RCC clock interrupt flag register,                                       Address offset: 0x1C */\n  __IO uint32_t CICR;        /*!&lt; RCC clock interrupt clear register,                                      Address offset: 0x20 */\n  uint32_t      RESERVED0;   /*!&lt; Reserved,                                                                Address offset: 0x24 */\n  __IO uint32_t AHB1RSTR;    /*!&lt; RCC AHB1 peripheral reset register,                                      Address offset: 0x28 */\n  __IO uint32_t AHB2RSTR;    /*!&lt; RCC AHB2 peripheral reset register,                                      Address offset: 0x2C */\n  __IO uint32_t AHB3RSTR;    /*!&lt; RCC AHB3 peripheral reset register,                                      Address offset: 0x30 */\n  uint32_t      RESERVED1;   /*!&lt; Reserved,                                                                Address offset: 0x34 */\n  __IO uint32_t APB1RSTR1;   /*!&lt; RCC APB1 peripheral reset register 1,                                    Address offset: 0x38 */\n  __IO uint32_t APB1RSTR2;   /*!&lt; RCC APB1 peripheral reset register 2,                                    Address offset: 0x3C */\n  __IO uint32_t APB2RSTR;    /*!&lt; RCC APB2 peripheral reset register,                                      Address offset: 0x40 */\n  uint32_t      RESERVED2;   /*!&lt; Reserved,                                                                Address offset: 0x44 */\n  __IO uint32_t AHB1ENR;     /*!&lt; RCC AHB1 peripheral clocks enable register,                              Address offset: 0x48 */\n  __IO uint32_t AHB2ENR;     /*!&lt; RCC AHB2 peripheral clocks enable register,                              Address offset: 0x4C */\n  __IO uint32_t AHB3ENR;     /*!&lt; RCC AHB3 peripheral clocks enable register,                              Address offset: 0x50 */\n  uint32_t      RESERVED3;   /*!&lt; Reserved,                                                                Address offset: 0x54 */\n  __IO uint32_t APB1ENR1;    /*!&lt; RCC APB1 peripheral clocks enable register 1,                            Address offset: 0x58 */\n  __IO uint32_t APB1ENR2;    /*!&lt; RCC APB1 peripheral clocks enable register 2,                            Address offset: 0x5C */\n  __IO uint32_t APB2ENR;     /*!&lt; RCC APB2 peripheral clocks enable register,                              Address offset: 0x60 */\n  uint32_t      RESERVED4;   /*!&lt; Reserved,                                                                Address offset: 0x64 */\n  __IO uint32_t AHB1SMENR;   /*!&lt; RCC AHB1 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x68 */\n  __IO uint32_t AHB2SMENR;   /*!&lt; RCC AHB2 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x6C */\n  __IO uint32_t AHB3SMENR;   /*!&lt; RCC AHB3 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x70 */\n  uint32_t      RESERVED5;   /*!&lt; Reserved,                                                                Address offset: 0x74 */\n  __IO uint32_t APB1SMENR1;  /*!&lt; RCC APB1 peripheral clocks enable in sleep mode and stop modes register 1, Address offset: 0x78 */\n  __IO uint32_t APB1SMENR2;  /*!&lt; RCC APB1 peripheral clocks enable in sleep mode and stop modes register 2, Address offset: 0x7C */\n  __IO uint32_t APB2SMENR;   /*!&lt; RCC APB2 peripheral clocks enable in sleep mode and stop modes register, Address offset: 0x80 */\n  uint32_t      RESERVED6;   /*!&lt; Reserved,                                                                Address offset: 0x84 */\n  __IO uint32_t CCIPR;       /*!&lt; RCC peripherals independent clock configuration register,                Address offset: 0x88 */\n  uint32_t      RESERVED7;   /*!&lt; Reserved,                                                                Address offset: 0x8C */\n  __IO uint32_t BDCR;        /*!&lt; RCC backup domain control register,                                      Address offset: 0x90 */\n  __IO uint32_t CSR;         /*!&lt; RCC clock control & status register,                                     Address offset: 0x94 */\n  __IO uint32_t CRRCR;       /*!&lt; RCC clock recovery RC register,                                          Address offset: 0x98 */\n} RCC_TypeDef;\n\n#define RCC ((RCC_TypeDef *) RCC_BASE)\n\n///////////////////////////////////////////////////////////////////////////////\n// Function prototypes\n///////////////////////////////////////////////////////////////////////////////\n\nvoid configurePLL(void);\nvoid configureClock(void);\n\n#endif"
  },
  {
    "objectID": "labs/lab4/lab4.html#rcc-c-file",
    "href": "labs/lab4/lab4.html#rcc-c-file",
    "title": "Lab 4",
    "section": "RCC C File ",
    "text": "RCC C File \n// STM32L432KC_RCC.c\n// Source code for RCC functions\n\n#include \"STM32L432KC_RCC.h\"\n\nvoid configurePLL(void) {\n    // Set clock to 80 MHz\n    // Output freq = (src_clk) * (N/M) / R\n    // (4 MHz) * (80/1) / 4 = 80 MHz\n    // M: 1, N: 80, R: 4\n    // Use MSI as PLLSRC\n\n    // Turn off PLL\n    RCC-&gt;CR &= ~(1 &lt;&lt; 24);\n    \n    // Wait till PLL is unlocked (e.g., off)\n    while ((RCC-&gt;CR &gt;&gt; 25 & 1) != 0);\n\n    // Load configuration\n    // Set PLL SRC to MSI\n    RCC-&gt;PLLCFGR |= (1 &lt;&lt; 0);\n    RCC-&gt;PLLCFGR &= ~(1 &lt;&lt; 1);\n\n    // Set PLLN\n    RCC-&gt;PLLCFGR &= ~(0b11111111 &lt;&lt; 8); // Clear all bits of PLLN\n    RCC-&gt;PLLCFGR |= (0b1010000 &lt;&lt; 8); // |= 80\n    \n    // Set PLLM\n    RCC-&gt;PLLCFGR &= ~(0b111 &lt;&lt; 4);  // Clear all bits\n    \n    // Set PLLR\n    RCC-&gt;PLLCFGR &= ~(1 &lt;&lt; 26);\n    RCC-&gt;PLLCFGR |= (1 &lt;&lt; 25);\n    \n    // Enable PLLR output\n    RCC-&gt;PLLCFGR |= (1 &lt;&lt; 24);\n\n    // Enable PLL\n    RCC-&gt;CR |= (1 &lt;&lt; 24);\n    \n    // Wait until PLL is locked\n    while ((RCC-&gt;CR &gt;&gt; 25 & 1) != 1);\n}\n\nvoid configureClock(void){\n    // Configure and turn on PLL\n    configurePLL();\n\n    // Select PLL as clock source\n    RCC-&gt;CFGR |= (0b11 &lt;&lt; 0);\n    while(!((RCC-&gt;CFGR &gt;&gt; 2) & 0b11));\n}"
  },
  {
    "objectID": "labs/lab4/lab4.html#tim-15-and-16-header",
    "href": "labs/lab4/lab4.html#tim-15-and-16-header",
    "title": "Lab 4",
    "section": "Tim 15 and 16 Header ",
    "text": "Tim 15 and 16 Header \n//STM32L432KC_TIM1516.h\n//Header for TIM1516 functions\n\n#ifndef STM32L4_TIM_15_16_H\n#define STM32L4_TIM_15_16_H\n\n#include &lt;stdint.h&gt;\n#include \"STM32L432KC_GPIO.h\" // Include GPIO header for GPIO type\n#define __IO volatile\n\n//Base Address\n#define TIM16_BASE (0x40014400UL)\n#define TIM15_BASE (0x40014000UL)\n\n//Bit Field\n\ntypedef struct{\n  __IO uint32_t CR1; //0x00\n  __IO uint32_t CR2; //0x04\n  __IO uint32_t SMCR; //0x08\n  __IO uint32_t DIER; //0x0C\n  __IO uint32_t SR; //0x10\n  __IO uint32_t EGR; //0x14\n  __IO uint32_t CCMR1; //0x18\n  __IO uint32_t BLANK; //0x1C\n  __IO uint32_t CCER; //0x20\n  __IO uint32_t CNT; //0x24\n  __IO uint32_t PSC; //0x028\n  __IO uint32_t ARR; //0x2C\n  __IO uint32_t RCR; //0x30\n  __IO uint32_t CCR1; //0x34\n  __IO uint32_t CCR2; //0x38\n  __IO uint32_t BLANK1; //0x3C\n  __IO uint32_t BLANK2; //0x40\n  __IO uint32_t BDTR; //0x44\n  __IO uint32_t DCR; //0x48\n  __IO uint32_t DMAR; //0x4C\n  __IO uint32_t OR1; //0x50\n  __IO uint32_t BLANK3; //0x54\n  __IO uint32_t BLANK4; //0x5C\n  __IO uint32_t OR2; //0x60\n} TIM_1516_Typedef;\n\n#define TIM15 ((TIM_1516_Typedef *) TIM15_BASE)\n#define TIM16 ((TIM_1516_Typedef *) TIM16_BASE)\n\nvoid initTIM(TIM_1516_Typedef* TIMx,uint32_t PSC_VAL);\nvoid delay_millis(TIM_1516_Typedef * TIM1x, TIM_1516_Typedef * TIM2x,uint32_t ms,uint32_t Frequency,GPIO* GPIOx,int pin);\nvoid PWM(TIM_1516_Typedef* TIMx, uint32_t Frequency);\n\n#endif"
  },
  {
    "objectID": "labs/lab4/lab4.html#tim-15-and-16-c-file",
    "href": "labs/lab4/lab4.html#tim-15-and-16-c-file",
    "title": "Lab 4",
    "section": "Tim 15 and 16 C File ",
    "text": "Tim 15 and 16 C File \n// STM32L432KC_TIM_15_16.c\n// Source code for TIM functions\n\n#include \"STM32L432KC_TIM_15_16.h\"\n#include \"STM32L432KC_RCC.h\"\n#include \"STM32L432KC_GPIO.h\"\n\nvoid initTIM(TIM_1516_Typedef * TIMx,uint32_t PSC_VAL) {\n    TIMx-&gt;CR1 |=(1&lt;&lt;7); // Turn on ARPE\n    TIMx-&gt;PSC = PSC_VAL; // Prescaler value (40 MHz / (799 + 1) = 50 kHz)\n}\n\nvoid delay_millis(TIM_1516_Typedef * TIM1x, TIM_1516_Typedef * TIM2x,uint32_t ms,uint32_t Frequency,GPIO* GPIOx,int pin) {\n    TIM1x-&gt;ARR = ms*100; // Auto-reload value for ms delay (50 kHz clock) for PSC 799\n    printf(\"ARR is %lu\\n\",TIM1x-&gt;ARR);\n    TIM1x-&gt;EGR |= (1&lt;&lt;0); // Generate an update event \n    TIM1x-&gt;SR &= ~(1&lt;&lt;0); // Clear interrupt flag\n    TIM1x-&gt;CR1 |= (1&lt;&lt;0); // Start timer\n\n    // Wait until the update interrupt flag is set\n    while (((TIM1x-&gt;SR &gt;&gt; 0) & 1) == 0){\n        if(Frequency!=0){\n            //printf(\"CNT is %lu, ARR is %lu\\n\",TIM2x-&gt;CNT,TIM2x-&gt;ARR);\n            if(TIM2x-&gt;CNT &lt; TIM2x-&gt;ARR/2){\n                digitalWrite(GPIOx,pin,GPIO_HIGH);\n            }\n            else{\n                digitalWrite(GPIOx,pin,GPIO_LOW);\n            }\n        }   \n        else{\n            digitalWrite(GPIOx,pin,GPIO_LOW);\n        }\n    };\n\n    TIM1x-&gt;CR1 &= ~(1&lt;&lt;0); // Stop the time\n}\n\n\nvoid PWM(TIM_1516_Typedef * TIMx, uint32_t Frequency) {\n    TIMx-&gt;ARR = (8000000/(Frequency)); // Auto-reload value for ms delay (50 kHz clock)\n    TIMx-&gt;EGR |= (1&lt;&lt;0); // Generate an update event \n    TIMx-&gt;SR &= ~(1&lt;&lt;0); // Clear interrupt flag\n    TIMx-&gt;CR1 |= (1&lt;&lt;0); // Start timer\n    printf(\"ARR is %lu\\n\",TIMx-&gt;ARR);\n    \n    \n\n    \n    \n\n\n}"
  },
  {
    "objectID": "labs/lab4/lab4.html#flash-header",
    "href": "labs/lab4/lab4.html#flash-header",
    "title": "Lab 4",
    "section": "Flash Header ",
    "text": "Flash Header \n// STM32L432KC_FLASH.h\n// Header for FLASH functions\n\n#ifndef STM32L4_FLASH_H\n#define STM32L4_FLASH_H\n\n#include &lt;stdint.h&gt;\n\n///////////////////////////////////////////////////////////////////////////////\n// Definitions\n///////////////////////////////////////////////////////////////////////////////\n\n#define __IO volatile\n\n// Base addresses for GPIO ports\n#define FLASH_BASE (0x40022000UL) // base address of RCC\n\n///////////////////////////////////////////////////////////////////////////////\n// Bitfield struct for GPIO\n///////////////////////////////////////////////////////////////////////////////\n\ntypedef struct {\n  __IO uint32_t ACR;      /*!&lt; FLASH access control register,   Address offset: 0x00 */\n  __IO uint32_t KEYR;     /*!&lt; FLASH key register,              Address offset: 0x04 */\n  __IO uint32_t OPTKEYR;  /*!&lt; FLASH option key register,       Address offset: 0x08 */\n  __IO uint32_t SR;       /*!&lt; FLASH status register,           Address offset: 0x0C */\n  __IO uint32_t CR;       /*!&lt; FLASH control register,          Address offset: 0x10 */\n  __IO uint32_t OPTCR;    /*!&lt; FLASH option control register ,  Address offset: 0x14 */\n  __IO uint32_t OPTCR1;   /*!&lt; FLASH option control register 1, Address offset: 0x18 */\n} FLASH_TypeDef;\n\n#define FLASH ((FLASH_TypeDef *) FLASH_BASE)\n\n///////////////////////////////////////////////////////////////////////////////\n// Function prototypes\n///////////////////////////////////////////////////////////////////////////////\n\nvoid configureFlash(void);\n\n#endif"
  },
  {
    "objectID": "labs/lab4/lab4.html#flash-c-file",
    "href": "labs/lab4/lab4.html#flash-c-file",
    "title": "Lab 4",
    "section": "Flash C File ",
    "text": "Flash C File \n// STM32L432KC_FLASH.c\n// Source code for FLASH functions\n\n#include \"STM32L432KC_FLASH.h\"\n\nvoid configureFlash(void) {\n    FLASH-&gt;ACR |= (0b100); // Set to 4 waitstates\n    FLASH-&gt;ACR |= (1 &lt;&lt; 8); // Turn on the ART\n}"
  },
  {
    "objectID": "labs/lab4/lab4.html#gpio-header",
    "href": "labs/lab4/lab4.html#gpio-header",
    "title": "Lab 4",
    "section": "GPIO Header ",
    "text": "GPIO Header \n// STM32L432KC_GPIO.h\n// Header for GPIO functions\n\n#ifndef STM32L4_GPIO_H\n#define STM32L4_GPIO_H\n\n#include &lt;stdint.h&gt; // Include stdint header\n\n///////////////////////////////////////////////////////////////////////////////\n// Definitions\n///////////////////////////////////////////////////////////////////////////////\n\n// Values for GPIO pins (\"val\" arguments)\n#define GPIO_LOW    0\n#define GPIO_HIGH   1\n\n// Base addresses for GPIO ports\n#define GPIOB_BASE  (0x48000400UL)\n#define GPIOA_BASE  (0x48000000UL)\n\n// Arbitrary GPIO functions for pinMode()\n#define GPIO_INPUT  0\n#define GPIO_OUTPUT 1\n#define GPIO_ALT    2\n#define GPIO_ANALOG 3\n\n///////////////////////////////////////////////////////////////////////////////\n// Bitfield struct for GPIO\n///////////////////////////////////////////////////////////////////////////////\n\n// GPIO register structs here\ntypedef struct {\n    volatile uint32_t MODER;   // GPIO Offset 0x00 GPIO port mode register\n    volatile uint32_t OTYPER;  // GPIO Offset 0x04\n    volatile uint32_t OSPEEDR; // GPIO Offset 0x08\n    volatile uint32_t PURPDR;  // GPIO Offset 0x0C\n    volatile uint32_t IDR;     // GPIO Offset 0x10\n    volatile uint32_t ODR;     // GPIO Offset 0x14\n    volatile uint32_t BSRR;    // GPIO Offset 0x18\n    volatile uint32_t LCKR;    // GPIO Offset 0x1C\n    volatile uint32_t AFRL;    // GPIO Offset 0x20\n    volatile uint32_t AFRH;    // GPIO Offset 0x24\n} GPIO;\n\n// Pointers to GPIO-sized chunks of memory for each peripheral\n#define GPIOB ((GPIO *) GPIOB_BASE)\n#define GPIOA ((GPIO *) GPIOA_BASE)\n//#define GPIO GPIOB\n\n///////////////////////////////////////////////////////////////////////////////\n// Function prototypes\n///////////////////////////////////////////////////////////////////////////////\n\nvoid pinMode(GPIO* GPIOx,int pin, int function);\n\nint digitalRead(GPIO* GPIOx,int pin);\n\nvoid digitalWrite(GPIO* GPIOx,int pin, int val);\n\nvoid togglePin(GPIO* GPIOx,int pin);\n\n#endif"
  },
  {
    "objectID": "labs/lab4/lab4.html#gpio-c",
    "href": "labs/lab4/lab4.html#gpio-c",
    "title": "Lab 4",
    "section": "GPIO C ",
    "text": "GPIO C \n// STM32L432KC_GPIO.c\n// Source code for GPIO functions\n\n#include \"STM32L432KC_GPIO.h\"\n\nvoid pinMode(GPIO* GPIOx,int pin, int function) {\n    switch(function) {\n        case GPIO_INPUT:\n            GPIOx-&gt;MODER &= ~(0b11 &lt;&lt; 2*pin);\n            break;\n        case GPIO_OUTPUT:\n            GPIOx-&gt;MODER |= (0b1 &lt;&lt; 2*pin);\n            GPIOx-&gt;MODER &= ~(0b1 &lt;&lt; (2*pin+1));\n            break;\n        case GPIO_ALT:\n            //sets moder\n            GPIOx-&gt;MODER &= ~(0b1 &lt;&lt; 2*pin);\n            GPIOx-&gt;MODER |= (0b1 &lt;&lt; (2*pin+1));\n            //sets as push pull\n            //GPIOx-&gt;OTYPER |= (0b1 &lt;&lt; pin); // Push-pull\n            GPIOx-&gt;AFRL |= (0b1110 &lt;&lt; 4*pin); // Clear bits\n            break;\n        case GPIO_ANALOG:\n            GPIOx-&gt;MODER |= (0b11 &lt;&lt; 2*pin);\n            break;\n    }\n}\n\nint digitalRead(GPIO* GPIOx,int pin) {\n    return ((GPIOx-&gt;IDR) &gt;&gt; pin) & 1;\n}\n\nvoid digitalWrite(GPIO* GPIOx,int pin, int val) {\n    if(val == GPIO_LOW)\n        GPIOx-&gt;ODR &= ~(1 &lt;&lt; pin);\n    else\n    GPIOx-&gt;ODR |= (1 &lt;&lt; pin);\n}\n\nvoid togglePin(GPIO* GPIOx,int pin) {\n    // Use XOR to toggle\n    GPIOx-&gt;ODR ^= (1 &lt;&lt; pin);\n}"
  },
  {
    "objectID": "labs/lab4/lab4.html#max-min-frequency",
    "href": "labs/lab4/lab4.html#max-min-frequency",
    "title": "Lab 4",
    "section": "Max Min Frequency ",
    "text": "Max Min Frequency \n ## Error   # Notes"
  },
  {
    "objectID": "labs/lab4/lab4.html#which-timers-can-you-use",
    "href": "labs/lab4/lab4.html#which-timers-can-you-use",
    "title": "Lab 4",
    "section": "1. Which timers can you use?",
    "text": "1. Which timers can you use?\nThe STM32L432KC has several general-purpose and advanced timers:\n\nTIM1 (advanced control, 16-bit, has complementary outputs, dead-time, etc.)\nTIM2 (general-purpose, 32-bit)\nTIM15, TIM16, TIM17 (16-bit, smaller general-purpose timers)\nLPTIM1, LPTIM2 (low-power timers, good for ultra-low-frequency and low-power applications, but less flexible for PWM).\n\n👉 For your use case (simple output waveforms at ~200 Hz–1 kHz):\n\nTIM2 is a great choice because it’s 32-bit, so you don’t need to worry about overflow.\nTIM1 or TIM15 are also good choices if you want direct PWM routing to GPIO pins with advanced features.\nIf you want the easiest connection to a GPIO pin, choose TIM2, TIM1, or TIM15, since they have well-documented alternate functions (AF) for output compare/PWM on pins."
  },
  {
    "objectID": "labs/lab4/lab4.html#how-do-you-generate-the-frequency",
    "href": "labs/lab4/lab4.html#how-do-you-generate-the-frequency",
    "title": "Lab 4",
    "section": "2. How do you generate the frequency?",
    "text": "2. How do you generate the frequency?\nA timer frequency is controlled by three things:\n[ f_{out} = ]\nWhere:\n\n(f_{TIM}) = timer clock frequency (depends on APB prescaler — typically up to 80 MHz on STM32L432).\nPSC = prescaler register (TIMx_PSC)\nARR = auto-reload register (TIMx_ARR) → sets the period.\n\nIf you want a PWM (toggle a pin), you set an output compare mode (via TIMx_CCMR) and choose a duty cycle using the capture/compare register (TIMx_CCRx)."
  },
  {
    "objectID": "labs/lab4/lab4.html#example-calculation",
    "href": "labs/lab4/lab4.html#example-calculation",
    "title": "Lab 4",
    "section": "3. Example Calculation",
    "text": "3. Example Calculation\nSuppose your system clock is 80 MHz and APB1 prescaler is 1 → so (f_{TIM} = 80 MHz).\nTarget frequency = 500 Hz.\n[ (PSC+1)(ARR+1) = = = 160{,}000]\nPick something convenient:\n\nPSC = 159 → (PSC+1) = 160\nARR = 999 → (ARR+1) = 1000 → Frequency = (80,MHz / (160 ) = 500,Hz).\n\nFor 220 Hz: [ (PSC+1)(ARR+1) = ] You might choose PSC = 359, ARR ≈ 1009 → ~220 Hz.\nFor 1 kHz: [ (PSC+1)(ARR+1) = = 80{,}000] PSC = 79, ARR = 999 → 1 kHz."
  },
  {
    "objectID": "labs/lab4/lab4.html#key-registers-to-configure",
    "href": "labs/lab4/lab4.html#key-registers-to-configure",
    "title": "Lab 4",
    "section": "4. Key Registers to Configure",
    "text": "4. Key Registers to Configure\n\nEnable clock to timer\n\nRCC_APB1ENR1 (for TIM2, TIM15, etc.)\nRCC_APB2ENR (for TIM1).\n\nSet prescaler\n\nTIMx_PSC = value.\n\nSet auto-reload register (period)\n\nTIMx_ARR = value.\n\nEnable output compare/PWM mode\n\nConfigure TIMx_CCMR1 (or CCMR2 depending on channel).\nSet channel to PWM mode 1 or 2.\n\nSet duty cycle\n\nTIMx_CCRx = value (between 0 and ARR).\n\nEnable output pin\n\nConfigure GPIO pin to AF mode with the right AF mapping for your chosen timer/channel.\nSet TIMx_CCER bit to enable the channel output.\n\nEnable counter\n\nSet TIMx_CR1.CEN = 1."
  },
  {
    "objectID": "labs/lab4/lab4.html#summary-recommendation",
    "href": "labs/lab4/lab4.html#summary-recommendation",
    "title": "Lab 4",
    "section": "5. Summary Recommendation",
    "text": "5. Summary Recommendation\n\nUse TIM2 if you want flexibility (32-bit, simple).\nUse TIM1 or TIM15 if you specifically want advanced PWM features (e.g., complementary outputs).\nConnect to GPIO via alternate function mapping (check STM32L432 datasheet for AF mappings).\n\n\n👉 If you’d like, I can write out a bare-metal register configuration example (C code) for, say, TIM2 CH1 on a specific GPIO pin (PA0), generating 500 Hz PWM. Do you want me to write out that code?"
  },
  {
    "objectID": "labs/lab4/lab4.html#ai-reflection",
    "href": "labs/lab4/lab4.html#ai-reflection",
    "title": "Lab 4",
    "section": "AI reflection",
    "text": "AI reflection\nThe AI response compared to my own decision making was very similar. We both Identified that Timmers 15 could directly connect to gpio pins. However it doesn’t mention timmers 6 and 7.\nThe equation it gave were semi useful but was better was the foot note explaining how to program the pwm using output compare mode.\nIt has the same logic path as mine. However the way it tries to go is directly output the pwm wave to gpio pin. They miss parts about setting the polarity for the output enabling gpio pins and clocks."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2",
    "section": "",
    "text": "Introduction\nSchematic\nBlock Diagram\nVerilog Code 4.1 top 4.2 seven_seg_display 4.3 clock_divider\nTest Benches 5.1 testbench 5.2 seven_testbench\nNotes\n\n7.AI Prototype"
  },
  {
    "objectID": "labs/lab2/lab2.html#top",
    "href": "labs/lab2/lab2.html#top",
    "title": "Lab 2",
    "section": "top ",
    "text": "top \n/*\nTitle: top module for lab 2\nAuthor: Kanoa Parker\nEmail: kanparker@g.hmc.edu\nDate: 9/9/2024\nDescription: Top module for lab 2. Takes in inputs of 2 sets of 4 switches, s1 and s2. Outputs the sum of s1 and s2 as led. Using a time multiplexer the mux choses either to output either s1 or s2 as seg using seven_seg_display module. gate1 and gate1 go to transistor gates which control which set of leds get turned on.\n*/\nmodule top(\n    input logic [3:0]s1,\n    input logic [3:0]s2,\n    output logic [6:0]seg, \n    output logic [4:0]led,\n    output logic gate1, gate2,\n    output logic clk\n);\n    //s1 is inputs of one set of 4 dip swithces\n    //s2 is inputs of other set of 4 dip switches\n    //seg is the output to drive seven segment display\n    // gate1 and gate2 go to base of BJT to control power to seven segment display\n    // clk is output used for testing\n    \n    //sev_seg_in is the input to seven_seg_display module\n    logic [3:0]sev_seg_in;\n    \n    //sev_seg_out is the output of seven_seg_display module\n    logic [6:0]sev_seg_out;\n\n    //instancing seven_seg_display\n    seven_seg_display seven_seg_counter(sev_seg_in,seg);\n    //instancing clock divider\n    clock_divider slow_clock(clk);\n    \n    //muxing between s1 and s2\n    always_comb\n        case(clk)\n            1'b1: begin\n                    sev_seg_in = s1[3:0]; \n                    gate1 = 1'b1;\n                    gate2 =1'b0;\n                end\n            1'b0: begin\n                    sev_seg_in = s2[3:0];\n                    gate1 = 1'b0;\n                    gate2 = 1'b1;\n                end\n        endcase\n    //sum of s1 and s2 to led   \n        assign led = s1 + s2;\n        \nendmodule\nTop module for lab 2. Takes in inputs of 2 sets of 4 switches, s1 and s2. Outputs the sum of s1 and s2 as led. Using a time multiplexer the mux choses either to output either s1 or s2 as seg using seven_seg_display module. gate1 and gate1 go to transistor gates which control which set of leds get turned on."
  },
  {
    "objectID": "labs/lab2/lab2.html#seven_segment_display",
    "href": "labs/lab2/lab2.html#seven_segment_display",
    "title": "Lab 2",
    "section": "seven_segment_display ",
    "text": "seven_segment_display \n/*\nTitle: seven_seg_display\nAuthor: Kanoa Parker\nEmail: kanparker@g.hmc.edu\nDate: 9/9/2024\nDescription: Takes in 4 switch inputs and outputs control signal for a seven segment display\n*/\nmodule seven_seg_display(\n    input   logic   [3:0]s,\n    output  logic [6:0]seg\n);\n    //logic used for old boolean algebra method\n    logic A,B,C,D;\n    \n    assign A = s[3];\n    assign B = s[2];\n    assign C = s[1];\n    assign D = s[0];\n    \n    //old boolean algrebra method\n    /*\n    assign seg[6] = (~A&~C)&(B^D) | A&(~B&C&D | B&~C);\n    assign seg[5] = D&~(A^C) | B&(C&~D | A&~C&~D);\n    assign seg[4] = ~A&~B&C&~D | (A&B)&( ~C&~D | C);\n    assign seg[3] = (~A&D)& ~(B^C) | (A&~B)&(C^D) | B&( ~(A|C|D) | A&C&D);\n    assign seg[2] = (~A&~B&D) | (~A&B&~C) | (~A&B&C&D) | (A&~B&~C&D);\n    assign seg[1] = (~(A|B|C) & D) | (~A&~B&C) | (~A&B&C&D) | (A&B&~C);\n    assign seg[0] = ~(A|B|C|D) | (~A&~B&~C&D) | (~A&B&C&D);\n    */\n    \n    //case statement that map input to output\n    always_comb\n        case(s[3:0])\n            /// 0\n            4'b0000: seg[6:0] = 7'b0000001;\n            /// 1\n            4'b0001: seg[6:0] = 7'b1001111;\n            /// 2\n            4'b0010: seg[6:0] = 7'b0010010;\n            /// 3\n            4'b0011:seg[6:0] = 7'b0000110;\n            /// 4\n            4'b0100:seg[6:0] = 7'b1001100;\n            /// 5\n            4'b0101:seg[6:0] = 7'b0100100;\n            /// 6\n            4'b0110:seg[6:0] = 7'b0100000;\n            /// 7\n            4'b0111:seg[6:0] = 7'b0001111;\n            /// 8\n            4'b1000:seg[6:0] = 7'b0000000;\n            /// 9\n            4'b1001:seg[6:0] = 7'b0001100;\n            /// A\n            4'b1010:seg[6:0] = 7'b0001000;\n            /// B\n            4'b1011:seg[6:0] = 7'b1100000;\n            /// C\n            4'b1100:seg[6:0] = 7'b0110001;\n            /// D\n            4'b1101:seg[6:0] = 7'b1000010;\n            /// E\n            4'b1110:seg[6:0] = 7'b0110000;\n            /// F\n            4'b1111:seg[6:0] = 7'b0111000;\n        endcase\n            \n    //see notes for segment conrispondice to led\n\nendmodule\nSeven segment display takes an input of four switches, s[3:0], and ouputs to light up the seven segment display, seg[6:0]"
  },
  {
    "objectID": "labs/lab2/lab2.html#clock_divider",
    "href": "labs/lab2/lab2.html#clock_divider",
    "title": "Lab 2",
    "section": "clock_divider ",
    "text": "clock_divider \n/*\nTitle: clock_divider\nAuthor: Kanoa Parker\nEmail: kanparker@g.hmc.edu\nDate: 9/9/2024\nDescription: Takes in the standard oscillator adn divides the clock using a counter to produce a clock at desired frequency\n*/\n\nmodule clock_divider(\n    output clk\n);\n    \n    logic int_osc;\n    logic pulse;\n    logic led_state = 0;\n    logic [31:0] counter = 0;\n    logic [31:0] P;\n    \n    assign P = 32'b00000000000000010101111110010000;\n    \n    // Internal high-speed oscillator\n    HSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(int_osc));\n    \n    // Simple clock divider\n    always_ff @(posedge int_osc)\n        begin\n            counter &lt;= counter + P;\n        end\n    assign clk = counter[31];\n        \nendmodule\nTakes in the standard oscillator adn divides the clock using a counter to produce a clock at desired frequency."
  },
  {
    "objectID": "labs/lab2/lab2.html#test_bench",
    "href": "labs/lab2/lab2.html#test_bench",
    "title": "Lab 2",
    "section": "test_bench ",
    "text": "test_bench \n Link to Test Bench File"
  },
  {
    "objectID": "labs/lab2/lab2.html#seven_testbench",
    "href": "labs/lab2/lab2.html#seven_testbench",
    "title": "Lab 2",
    "section": "seven_testbench ",
    "text": "seven_testbench \n Link to Test Bench File"
  },
  {
    "objectID": "labs/lab2/lab2.html#code-ai-provided-first-try",
    "href": "labs/lab2/lab2.html#code-ai-provided-first-try",
    "title": "Lab 2",
    "section": "Code AI Provided first try",
    "text": "Code AI Provided first try\nmodule time_multiplexed_decoder (\n    input logic clk,               // Clock signal\n    input logic rst_n,             // Active-low reset signal\n    input logic [3:0] input_bits_1, // First set of 4-bit input\n    input logic [3:0] input_bits_2, // Second set of 4-bit input\n    output logic [6:0] seg_out_1,   // 7-segment output for the first set\n    output logic [6:0] seg_out_2    // 7-segment output for the second set\n);\n\n    // 7-segment display encoding for common anode (active low segments)\n    // Assuming the 7 segments are ordered as ABCDEF-G\n    logic [6:0] seven_seg_decoder [15:0] = {\n        7'b1111110,  // 0\n        7'b0110000,  // 1\n        7'b1101101,  // 2\n        7'b1111001,  // 3\n        7'b0110011,  // 4\n        7'b1011011,  // 5\n        7'b1011111,  // 6\n        7'b1110000,  // 7\n        7'b1111111,  // 8\n        7'b1111011,  // 9\n        7'b1110111,  // A\n        7'b0011111,  // B\n        7'b1001110,  // C\n        7'b0111101,  // D\n        7'b1001111,  // E\n        7'b1000111   // F\n    };\n\n    // Internal signals for multiplexing control\n    logic mux_ctrl;  // Control signal to alternate between the two sets\n\n    // Time multiplexing logic to alternate between the two sets of inputs\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            mux_ctrl &lt;= 0;  // Reset control signal\n        end else begin\n            mux_ctrl &lt;= ~mux_ctrl;  // Toggle the control signal\n        end\n    end\n\n    // Drive the seven-segment display outputs based on the multiplexed input\n    always_comb begin\n        if (mux_ctrl) begin\n            // Decode the first set of input bits\n            seg_out_1 = seven_seg_decoder[input_bits_1];\n            seg_out_2 = 7'b1111111;  // Turn off second display\n        end else begin\n            // Decode the second set of input bits\n            seg_out_2 = seven_seg_decoder[input_bits_2];\n            seg_out_1 = 7'b1111111;  // Turn off first display\n        end\n    end\n\nendmodule\nThis code was provided without my files. It all compiled and this is the netlist analyzer \n##Code AI provided given my files\n// timescale optional for simulation\n`timescale 1ns/1ps\n\n// Time-multiplex one seven-seg decoder across two inputs to drive two 7-bit busses.\n// Assumes your decoder module is named `seven_seg_display` with ports .s[3:0] and .seg[6:0],\n// and that your clock source is `clock_divider` with port .clk.\nmodule sevenseg_dual_mux #(\n    // If your seven-seg is common-anode (active-low segments), leave ACTIVE_LOW=1.\n    // If it’s common-cathode (active-high segments), set ACTIVE_LOW=0.\n    parameter bit ACTIVE_LOW = 1\n) (\n    input  logic [3:0] s1,        // first 4-bit value\n    input  logic [3:0] s2,        // second 4-bit value\n    output logic [6:0] seg1,      // seven outputs for display 1\n    output logic [6:0] seg2       // seven outputs for display 2\n);\n\n    // -------------------------------------------------------------------------\n    // Clock to flip which input is shown (multiplex rate is set inside clock_divider)\n    // -------------------------------------------------------------------------\n    logic clk_mux;\n    clock_divider u_div (.clk(clk_mux));\n\n    // -------------------------------------------------------------------------\n    // Shared decoder: one instance, two inputs selected by a toggle\n    // -------------------------------------------------------------------------\n    logic        sel;          // which input is currently active\n    logic [3:0]  nibble;       // goes into the shared decoder\n    logic [6:0]  seg_raw;      // comes out of the shared decoder\n\n    // Simple toggle at the divided clock to alternate inputs\n    always_ff @(posedge clk_mux) begin\n        sel &lt;= ~sel;\n    end\n\n    // The single decoder\n    seven_seg_display u_dec (\n        .s   (nibble),\n        .seg (seg_raw)\n    );\n\n    // -------------------------------------------------------------------------\n    // Demultiplex the decoded segments to two 7-bit outputs.\n    // The non-selected display is driven \"blank\" to avoid ghosting.\n    // For active-low segments, \"blank\" = all 1s; for active-high, \"blank\" = all 0s.\n    // -------------------------------------------------------------------------\n    localparam logic [6:0] BLANK = (ACTIVE_LOW) ? 7'b111_1111 : 7'b000_0000;\n\n    always_comb begin\n        // Default blank both\n        seg1  = BLANK;\n        seg2  = BLANK;\n\n        // Select which input feeds the decoder\n        nibble = sel ? s1 : s2;\n\n        // And route the decoder outputs to the selected display\n        if (sel) begin\n            seg1 = seg_raw;\n        end else begin\n            seg2 = seg_raw;\n        end\n    end\n\nendmodule\nCode failed with error “0Runing Export Files failed”"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Hi im Kanoa Parker and this is my Portfolio. I’m a senior engineering major at Harvey Mudd College focusing in Electrical Engineering. In my free time I like to listen to music. Here is my LinkedIN\nThis is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Hello Quarto\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 29, 205\n\n\nKanoa Parker\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1",
    "section": "",
    "text": "Introduction\nSchematic\nBlock Diagram\nVerilog Code 4.1 top 4.2 seven_segment_display 4.3 three_led\nTest Benches 5.1 testbench 5.2 seven_testbench 5.3 three_testbench\nNotes"
  },
  {
    "objectID": "labs/lab1/lab1.html#top",
    "href": "labs/lab1/lab1.html#top",
    "title": "Lab 1",
    "section": "top ",
    "text": "top \nmodule top(\n    input   logic   [3:0]s,\n    output  logic [2:0]led,\n    output logic [6:0]seg\n);\n\n    three_led three(s, led);\n    seven_seg_display seven(s,seg);\n    \n    \n\nendmodule\nTop level module."
  },
  {
    "objectID": "labs/lab1/lab1.html#seven_segment_display",
    "href": "labs/lab1/lab1.html#seven_segment_display",
    "title": "Lab 1",
    "section": "seven_segment_display ",
    "text": "seven_segment_display \nmodule seven_seg_display(\n    input   logic   [3:0]s,\n    output  logic [6:0]seg\n);\n\n    logic A,B,C,D;\n    \n    assign A = s[3];\n    assign B = s[2];\n    assign C = s[1];\n    assign D = s[0];\n    \n    assign seg[6] = (~A&~C)&(B^D) | A&(~B&C&D | B&~C);\n    assign seg[5] = D&~(A^C) | B&(C&~D | A&~C&~D);\n    assign seg[4] = ~A&~B&C&~D | (A&B)&( ~C&~D | C);\n    assign seg[3] = (~A&D)& ~(B^C) | (A&~B)&(C^D) | B&( ~(A|C|D) | A&C&D);\n    assign seg[2] = (~A&~B&D) | (~A&B&~C) | (~A&B&C&D) | (A&~B&~C&D);\n    assign seg[1] = (~(A|B|C) & D) | (~A&~B&C) | (~A&B&C&D) | (A&B&~C);\n    assign seg[0] = ~(A|B|C|D) | (~A&~B&~C&D) | (~A&B&C&D);\n    \n\nendmodule\nSeven segment display takes an input of four switches, s[3:0], and ouputs to light up the seven segment display, seg[6:0]"
  },
  {
    "objectID": "labs/lab1/lab1.html#three_led",
    "href": "labs/lab1/lab1.html#three_led",
    "title": "Lab 1",
    "section": "three_led ",
    "text": "three_led \nmodule three_led(\n    input   logic   [3:0]s,\n    output  logic [2:0]led\n);\n\n    logic int_osc;\n    logic pulse;\n    logic led_state = 0;\n    logic [31:0] counter = 0;\n    logic [31:0] P;\n    \n    assign P = 32'b00000000000000000000000011010111;\n    \n    // Internal high-speed oscillator\n    HSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(int_osc));\n    \n    // Simple clock divider\n    always_ff @(posedge int_osc)\n        begin\n            counter &lt;= counter + P;\n        end\n    \n    xor x1(led[0],s[1],s[0]);\n    and a1(led[1],s[3],s[2]);\n    \n    assign led[2] = counter[31];\n    \n\nendmodule\nThree led takes in an input of four switches, s[3:0], and turns on or off leds, led[2:0]."
  },
  {
    "objectID": "labs/lab1/lab1.html#test_bench",
    "href": "labs/lab1/lab1.html#test_bench",
    "title": "Lab 1",
    "section": "test_bench ",
    "text": "test_bench \n Link to Test Bench File"
  },
  {
    "objectID": "labs/lab1/lab1.html#seven_testbench",
    "href": "labs/lab1/lab1.html#seven_testbench",
    "title": "Lab 1",
    "section": "seven_testbench ",
    "text": "seven_testbench \n Link to Test Bench File"
  },
  {
    "objectID": "labs/lab1/lab1.html#three_testbench",
    "href": "labs/lab1/lab1.html#three_testbench",
    "title": "Lab 1",
    "section": "three_testbench ",
    "text": "three_testbench \n Link to Test Bench File"
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3",
    "section": "",
    "text": "Lab 3 tbd"
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5",
    "section": "",
    "text": "Lab 5 tbd"
  },
  {
    "objectID": "labs/lab7/lab7.html",
    "href": "labs/lab7/lab7.html",
    "title": "Lab 7",
    "section": "",
    "text": "Lab 7 tbd"
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Hello Quarto",
    "section": "",
    "text": "My goals for this semster in micro p’s is to learn as much as I can. I want to get into a good work flow schedule and manage my time well. I think I can achieve this by setting aside specific time to do work and staying focused. We will see"
  }
]